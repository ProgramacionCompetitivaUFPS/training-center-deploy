(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors~cc0898aa"],{

/***/ "c/xF":
/*!****************************************************************!*\
  !*** ./node_modules/bootstrap-tour/build/js/bootstrap-tour.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* ========================================================================\n * bootstrap-tour - v0.11.0\n * http://bootstraptour.com\n * ========================================================================\n * Copyright 2012-2015 Ulrich Sossou\n *\n * ========================================================================\n * Licensed under the MIT License (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://opensource.org/licenses/MIT\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ========================================================================\n */\n\nvar bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n(function(window, factory) {\n  if (true) {\n    return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"EVdn\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(jQuery) {\n      return window.Tour = factory(jQuery);\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(window, function($) {\n  var Tour, document;\n  document = window.document;\n  Tour = (function() {\n    function Tour(options) {\n      this._showPopoverAndOverlay = bind(this._showPopoverAndOverlay, this);\n      var storage;\n      try {\n        storage = window.localStorage;\n      } catch (error) {\n        storage = false;\n      }\n      this._options = $.extend({\n        name: 'tour',\n        steps: [],\n        container: 'body',\n        autoscroll: true,\n        keyboard: true,\n        storage: storage,\n        debug: false,\n        backdrop: false,\n        backdropContainer: 'body',\n        backdropPadding: 0,\n        redirect: true,\n        orphan: false,\n        duration: false,\n        delay: false,\n        basePath: '',\n        template: '<div class=\"popover\" role=\"tooltip\"> <div class=\"arrow\"></div> <h3 class=\"popover-title\"></h3> <div class=\"popover-content\"></div> <div class=\"popover-navigation\"> <div class=\"btn-group\"> <button class=\"btn btn-sm btn-default\" data-role=\"prev\">&laquo; Prev</button> <button class=\"btn btn-sm btn-default\" data-role=\"next\">Next &raquo;</button> <button class=\"btn btn-sm btn-default\" data-role=\"pause-resume\" data-pause-text=\"Pause\" data-resume-text=\"Resume\">Pause</button> </div> <button class=\"btn btn-sm btn-default\" data-role=\"end\">End tour</button> </div> </div>',\n        afterSetState: function(key, value) {},\n        afterGetState: function(key, value) {},\n        afterRemoveState: function(key) {},\n        onStart: function(tour) {},\n        onEnd: function(tour) {},\n        onShow: function(tour) {},\n        onShown: function(tour) {},\n        onHide: function(tour) {},\n        onHidden: function(tour) {},\n        onNext: function(tour) {},\n        onPrev: function(tour) {},\n        onPause: function(tour, duration) {},\n        onResume: function(tour, duration) {},\n        onRedirectError: function(tour) {}\n      }, options);\n      this._force = false;\n      this._inited = false;\n      this._current = null;\n      this.backdrops = [];\n      this;\n    }\n\n    Tour.prototype.addSteps = function(steps) {\n      var j, len, step;\n      for (j = 0, len = steps.length; j < len; j++) {\n        step = steps[j];\n        this.addStep(step);\n      }\n      return this;\n    };\n\n    Tour.prototype.addStep = function(step) {\n      this._options.steps.push(step);\n      return this;\n    };\n\n    Tour.prototype.getStep = function(i) {\n      if (this._options.steps[i] != null) {\n        return $.extend({\n          id: \"step-\" + i,\n          path: '',\n          host: '',\n          placement: 'right',\n          title: '',\n          content: '<p></p>',\n          next: i === this._options.steps.length - 1 ? -1 : i + 1,\n          prev: i - 1,\n          animation: true,\n          container: this._options.container,\n          autoscroll: this._options.autoscroll,\n          backdrop: this._options.backdrop,\n          backdropContainer: this._options.backdropContainer,\n          backdropPadding: this._options.backdropPadding,\n          redirect: this._options.redirect,\n          reflexElement: this._options.steps[i].element,\n          backdropElement: this._options.steps[i].element,\n          orphan: this._options.orphan,\n          duration: this._options.duration,\n          delay: this._options.delay,\n          template: this._options.template,\n          onShow: this._options.onShow,\n          onShown: this._options.onShown,\n          onHide: this._options.onHide,\n          onHidden: this._options.onHidden,\n          onNext: this._options.onNext,\n          onPrev: this._options.onPrev,\n          onPause: this._options.onPause,\n          onResume: this._options.onResume,\n          onRedirectError: this._options.onRedirectError\n        }, this._options.steps[i]);\n      }\n    };\n\n    Tour.prototype.init = function(force) {\n      this._force = force;\n      if (this.ended()) {\n        this._debug('Tour ended, init prevented.');\n        return this;\n      }\n      this.setCurrentStep();\n      this._initMouseNavigation();\n      this._initKeyboardNavigation();\n      this._onResize((function(_this) {\n        return function() {\n          return _this.showStep(_this._current);\n        };\n      })(this));\n      this._onScroll((function(_this) {\n        return function() {\n          return _this._showPopoverAndOverlay(_this._current);\n        };\n      })(this));\n      if (this._current !== null) {\n        this.showStep(this._current);\n      }\n      this._inited = true;\n      return this;\n    };\n\n    Tour.prototype.start = function(force) {\n      var promise;\n      if (force == null) {\n        force = false;\n      }\n      if (!this._inited) {\n        this.init(force);\n      }\n      if (this._current === null) {\n        promise = this._makePromise(this._options.onStart != null ? this._options.onStart(this) : void 0);\n        this._callOnPromiseDone(promise, this.showStep, 0);\n      }\n      return this;\n    };\n\n    Tour.prototype.next = function() {\n      var promise;\n      promise = this.hideStep(this._current, this._current + 1);\n      return this._callOnPromiseDone(promise, this._showNextStep);\n    };\n\n    Tour.prototype.prev = function() {\n      var promise;\n      promise = this.hideStep(this._current, this._current - 1);\n      return this._callOnPromiseDone(promise, this._showPrevStep);\n    };\n\n    Tour.prototype.goTo = function(i) {\n      var promise;\n      promise = this.hideStep(this._current, i);\n      return this._callOnPromiseDone(promise, this.showStep, i);\n    };\n\n    Tour.prototype.end = function() {\n      var endHelper, promise;\n      endHelper = (function(_this) {\n        return function(e) {\n          $(document).off(\"click.tour-\" + _this._options.name);\n          $(document).off(\"keyup.tour-\" + _this._options.name);\n          $(window).off(\"resize.tour-\" + _this._options.name);\n          $(window).off(\"scroll.tour-\" + _this._options.name);\n          _this._setState('end', 'yes');\n          _this._inited = false;\n          _this._force = false;\n          _this._clearTimer();\n          if (_this._options.onEnd != null) {\n            return _this._options.onEnd(_this);\n          }\n        };\n      })(this);\n      promise = this.hideStep(this._current);\n      return this._callOnPromiseDone(promise, endHelper);\n    };\n\n    Tour.prototype.ended = function() {\n      return !this._force && !!this._getState('end');\n    };\n\n    Tour.prototype.restart = function() {\n      this._removeState('current_step');\n      this._removeState('end');\n      this._removeState('redirect_to');\n      return this.start();\n    };\n\n    Tour.prototype.pause = function() {\n      var step;\n      step = this.getStep(this._current);\n      if (!(step && step.duration)) {\n        return this;\n      }\n      this._paused = true;\n      this._duration -= new Date().getTime() - this._start;\n      window.clearTimeout(this._timer);\n      this._debug(\"Paused/Stopped step \" + (this._current + 1) + \" timer (\" + this._duration + \" remaining).\");\n      if (step.onPause != null) {\n        return step.onPause(this, this._duration);\n      }\n    };\n\n    Tour.prototype.resume = function() {\n      var step;\n      step = this.getStep(this._current);\n      if (!(step && step.duration)) {\n        return this;\n      }\n      this._paused = false;\n      this._start = new Date().getTime();\n      this._duration = this._duration || step.duration;\n      this._timer = window.setTimeout((function(_this) {\n        return function() {\n          if (_this._isLast()) {\n            return _this.next();\n          } else {\n            return _this.end();\n          }\n        };\n      })(this), this._duration);\n      this._debug(\"Started step \" + (this._current + 1) + \" timer with duration \" + this._duration);\n      if ((step.onResume != null) && this._duration !== step.duration) {\n        return step.onResume(this, this._duration);\n      }\n    };\n\n    Tour.prototype.hideStep = function(i, iNext) {\n      var hideDelay, hideStepHelper, promise, step;\n      step = this.getStep(i);\n      if (!step) {\n        return;\n      }\n      this._clearTimer();\n      promise = this._makePromise(step.onHide != null ? step.onHide(this, i) : void 0);\n      hideStepHelper = (function(_this) {\n        return function(e) {\n          var $element, next_step;\n          $element = $(step.element);\n          if (!($element.data('bs.popover') || $element.data('popover'))) {\n            $element = $('body');\n          }\n          $element.popover('destroy').removeClass(\"tour-\" + _this._options.name + \"-element tour-\" + _this._options.name + \"-\" + i + \"-element\").removeData('bs.popover');\n          if (step.reflex) {\n            $(step.reflexElement).removeClass('tour-step-element-reflex').off((_this._reflexEvent(step.reflex)) + \".tour-\" + _this._options.name);\n          }\n          if (step.backdrop) {\n            next_step = (iNext != null) && _this.getStep(iNext);\n            if (!next_step || !next_step.backdrop || next_step.backdropElement !== step.backdropElement) {\n              _this._hideOverlayElement(step);\n            }\n          }\n          if (step.onHidden != null) {\n            return step.onHidden(_this);\n          }\n        };\n      })(this);\n      hideDelay = step.delay.hide || step.delay;\n      if ({}.toString.call(hideDelay) === '[object Number]' && hideDelay > 0) {\n        this._debug(\"Wait \" + hideDelay + \" milliseconds to hide the step \" + (this._current + 1));\n        window.setTimeout((function(_this) {\n          return function() {\n            return _this._callOnPromiseDone(promise, hideStepHelper);\n          };\n        })(this), hideDelay);\n      } else {\n        this._callOnPromiseDone(promise, hideStepHelper);\n      }\n      return promise;\n    };\n\n    Tour.prototype.showStep = function(i) {\n      var path, promise, showDelay, showStepHelper, skipToPrevious, step;\n      if (this.ended()) {\n        this._debug('Tour ended, showStep prevented.');\n        return this;\n      }\n      step = this.getStep(i);\n      if (!step) {\n        return;\n      }\n      skipToPrevious = i < this._current;\n      promise = this._makePromise(step.onShow != null ? step.onShow(this, i) : void 0);\n      this.setCurrentStep(i);\n      path = (function() {\n        switch ({}.toString.call(step.path)) {\n          case '[object Function]':\n            return step.path();\n          case '[object String]':\n            return this._options.basePath + step.path;\n          default:\n            return step.path;\n        }\n      }).call(this);\n      if (step.redirect && this._isRedirect(step.host, path, document.location)) {\n        this._redirect(step, i, path);\n        if (!this._isJustPathHashDifferent(step.host, path, document.location)) {\n          return;\n        }\n      }\n      showStepHelper = (function(_this) {\n        return function(e) {\n          if (_this._isOrphan(step)) {\n            if (step.orphan === false) {\n              _this._debug(\"Skip the orphan step \" + (_this._current + 1) + \".\\nOrphan option is false and the element does not exist or is hidden.\");\n              if (skipToPrevious) {\n                _this._showPrevStep();\n              } else {\n                _this._showNextStep();\n              }\n              return;\n            }\n            _this._debug(\"Show the orphan step \" + (_this._current + 1) + \". Orphans option is true.\");\n          }\n          if (step.autoscroll) {\n            _this._scrollIntoView(i);\n          } else {\n            _this._showPopoverAndOverlay(i);\n          }\n          if (step.duration) {\n            return _this.resume();\n          }\n        };\n      })(this);\n      showDelay = step.delay.show || step.delay;\n      if ({}.toString.call(showDelay) === '[object Number]' && showDelay > 0) {\n        this._debug(\"Wait \" + showDelay + \" milliseconds to show the step \" + (this._current + 1));\n        window.setTimeout((function(_this) {\n          return function() {\n            return _this._callOnPromiseDone(promise, showStepHelper);\n          };\n        })(this), showDelay);\n      } else {\n        this._callOnPromiseDone(promise, showStepHelper);\n      }\n      return promise;\n    };\n\n    Tour.prototype.getCurrentStep = function() {\n      return this._current;\n    };\n\n    Tour.prototype.setCurrentStep = function(value) {\n      if (value != null) {\n        this._current = value;\n        this._setState('current_step', value);\n      } else {\n        this._current = this._getState('current_step');\n        this._current = this._current === null ? null : parseInt(this._current, 10);\n      }\n      return this;\n    };\n\n    Tour.prototype.redraw = function() {\n      return this._showOverlayElement(this.getStep(this.getCurrentStep()));\n    };\n\n    Tour.prototype._setState = function(key, value) {\n      var e, keyName;\n      if (this._options.storage) {\n        keyName = this._options.name + \"_\" + key;\n        try {\n          this._options.storage.setItem(keyName, value);\n        } catch (error) {\n          e = error;\n          if (e.code === DOMException.QUOTA_EXCEEDED_ERR) {\n            this._debug('LocalStorage quota exceeded. State storage failed.');\n          }\n        }\n        return this._options.afterSetState(keyName, value);\n      } else {\n        if (this._state == null) {\n          this._state = {};\n        }\n        return this._state[key] = value;\n      }\n    };\n\n    Tour.prototype._removeState = function(key) {\n      var keyName;\n      if (this._options.storage) {\n        keyName = this._options.name + \"_\" + key;\n        this._options.storage.removeItem(keyName);\n        return this._options.afterRemoveState(keyName);\n      } else {\n        if (this._state != null) {\n          return delete this._state[key];\n        }\n      }\n    };\n\n    Tour.prototype._getState = function(key) {\n      var keyName, value;\n      if (this._options.storage) {\n        keyName = this._options.name + \"_\" + key;\n        value = this._options.storage.getItem(keyName);\n      } else {\n        if (this._state != null) {\n          value = this._state[key];\n        }\n      }\n      if (value === void 0 || value === 'null') {\n        value = null;\n      }\n      this._options.afterGetState(key, value);\n      return value;\n    };\n\n    Tour.prototype._showNextStep = function() {\n      var promise, showNextStepHelper, step;\n      step = this.getStep(this._current);\n      showNextStepHelper = (function(_this) {\n        return function(e) {\n          return _this.showStep(step.next);\n        };\n      })(this);\n      promise = this._makePromise(step.onNext != null ? step.onNext(this) : void 0);\n      return this._callOnPromiseDone(promise, showNextStepHelper);\n    };\n\n    Tour.prototype._showPrevStep = function() {\n      var promise, showPrevStepHelper, step;\n      step = this.getStep(this._current);\n      showPrevStepHelper = (function(_this) {\n        return function(e) {\n          return _this.showStep(step.prev);\n        };\n      })(this);\n      promise = this._makePromise(step.onPrev != null ? step.onPrev(this) : void 0);\n      return this._callOnPromiseDone(promise, showPrevStepHelper);\n    };\n\n    Tour.prototype._debug = function(text) {\n      if (this._options.debug) {\n        return window.console.log(\"Bootstrap Tour '\" + this._options.name + \"' | \" + text);\n      }\n    };\n\n    Tour.prototype._isRedirect = function(host, path, location) {\n      var currentPath;\n      if ((host != null) && host !== '' && (({}.toString.call(host) === '[object RegExp]' && !host.test(location.origin)) || ({}.toString.call(host) === '[object String]' && this._isHostDifferent(host, location)))) {\n        return true;\n      }\n      currentPath = [location.pathname, location.search, location.hash].join('');\n      return (path != null) && path !== '' && (({}.toString.call(path) === '[object RegExp]' && !path.test(currentPath)) || ({}.toString.call(path) === '[object String]' && this._isPathDifferent(path, currentPath)));\n    };\n\n    Tour.prototype._isHostDifferent = function(host, location) {\n      switch ({}.toString.call(host)) {\n        case '[object RegExp]':\n          return !host.test(location.origin);\n        case '[object String]':\n          return this._getProtocol(host) !== this._getProtocol(location.href) || this._getHost(host) !== this._getHost(location.href);\n        default:\n          return true;\n      }\n    };\n\n    Tour.prototype._isPathDifferent = function(path, currentPath) {\n      return this._getPath(path) !== this._getPath(currentPath) || !this._equal(this._getQuery(path), this._getQuery(currentPath)) || !this._equal(this._getHash(path), this._getHash(currentPath));\n    };\n\n    Tour.prototype._isJustPathHashDifferent = function(host, path, location) {\n      var currentPath;\n      if ((host != null) && host !== '') {\n        if (this._isHostDifferent(host, location)) {\n          return false;\n        }\n      }\n      currentPath = [location.pathname, location.search, location.hash].join('');\n      if ({}.toString.call(path) === '[object String]') {\n        return this._getPath(path) === this._getPath(currentPath) && this._equal(this._getQuery(path), this._getQuery(currentPath)) && !this._equal(this._getHash(path), this._getHash(currentPath));\n      }\n      return false;\n    };\n\n    Tour.prototype._redirect = function(step, i, path) {\n      var href;\n      if ($.isFunction(step.redirect)) {\n        return step.redirect.call(this, path);\n      } else {\n        href = {}.toString.call(step.host) === '[object String]' ? \"\" + step.host + path : path;\n        this._debug(\"Redirect to \" + href);\n        if (this._getState('redirect_to') === (\"\" + i)) {\n          this._debug(\"Error redirection loop to \" + path);\n          this._removeState('redirect_to');\n          if (step.onRedirectError != null) {\n            return step.onRedirectError(this);\n          }\n        } else {\n          this._setState('redirect_to', \"\" + i);\n          return document.location.href = href;\n        }\n      }\n    };\n\n    Tour.prototype._isOrphan = function(step) {\n      return (step.element == null) || !$(step.element).length || $(step.element).is(':hidden') && ($(step.element)[0].namespaceURI !== 'http://www.w3.org/2000/svg');\n    };\n\n    Tour.prototype._isLast = function() {\n      return this._current < this._options.steps.length - 1;\n    };\n\n    Tour.prototype._showPopoverAndOverlay = function(i) {\n      var step;\n      if (this.getCurrentStep() !== i || this.ended()) {\n        return;\n      }\n      step = this.getStep(i);\n      if (step.backdrop) {\n        this._showOverlayElement(step);\n      }\n      this._showPopover(step, i);\n      if (step.onShown != null) {\n        step.onShown(this);\n      }\n      return this._debug(\"Step \" + (this._current + 1) + \" of \" + this._options.steps.length);\n    };\n\n    Tour.prototype._showPopover = function(step, i) {\n      var $element, $tip, isOrphan, options, shouldAddSmart;\n      $(\".tour-\" + this._options.name).remove();\n      options = $.extend({}, this._options);\n      isOrphan = this._isOrphan(step);\n      step.template = this._template(step, i);\n      if (isOrphan) {\n        step.element = 'body';\n        step.placement = 'top';\n      }\n      $element = $(step.element);\n      $element.addClass(\"tour-\" + this._options.name + \"-element tour-\" + this._options.name + \"-\" + i + \"-element\");\n      if (step.options) {\n        $.extend(options, step.options);\n      }\n      if (step.reflex && !isOrphan) {\n        $(step.reflexElement).addClass('tour-step-element-reflex').off((this._reflexEvent(step.reflex)) + \".tour-\" + this._options.name).on((this._reflexEvent(step.reflex)) + \".tour-\" + this._options.name, (function(_this) {\n          return function() {\n            if (_this._isLast()) {\n              return _this.next();\n            } else {\n              return _this.end();\n            }\n          };\n        })(this));\n      }\n      shouldAddSmart = step.smartPlacement === true && step.placement.search(/auto/i) === -1;\n      $element.popover({\n        placement: shouldAddSmart ? \"auto \" + step.placement : step.placement,\n        trigger: 'manual',\n        title: step.title,\n        content: step.content,\n        html: true,\n        animation: step.animation,\n        container: step.container,\n        template: step.template,\n        selector: step.element\n      }).popover('show');\n      $tip = $element.data('bs.popover') ? $element.data('bs.popover').tip() : $element.data('popover').tip();\n      $tip.attr('id', step.id);\n      if ($element.css('position') === 'fixed') {\n        $tip.css('position', 'fixed');\n      }\n      this._reposition($tip, step);\n      if (isOrphan) {\n        return this._center($tip);\n      }\n    };\n\n    Tour.prototype._template = function(step, i) {\n      var $navigation, $next, $prev, $resume, $template, template;\n      template = step.template;\n      if (this._isOrphan(step) && {}.toString.call(step.orphan) !== '[object Boolean]') {\n        template = step.orphan;\n      }\n      $template = $.isFunction(template) ? $(template(i, step)) : $(template);\n      $navigation = $template.find('.popover-navigation');\n      $prev = $navigation.find('[data-role=\"prev\"]');\n      $next = $navigation.find('[data-role=\"next\"]');\n      $resume = $navigation.find('[data-role=\"pause-resume\"]');\n      if (this._isOrphan(step)) {\n        $template.addClass('orphan');\n      }\n      $template.addClass(\"tour-\" + this._options.name + \" tour-\" + this._options.name + \"-\" + i);\n      if (step.reflex) {\n        $template.addClass(\"tour-\" + this._options.name + \"-reflex\");\n      }\n      if (step.prev < 0) {\n        $prev.addClass('disabled').prop('disabled', true).prop('tabindex', -1);\n      }\n      if (step.next < 0) {\n        $next.addClass('disabled').prop('disabled', true).prop('tabindex', -1);\n      }\n      if (!step.duration) {\n        $resume.remove();\n      }\n      return $template.clone().wrap('<div>').parent().html();\n    };\n\n    Tour.prototype._reflexEvent = function(reflex) {\n      if ({}.toString.call(reflex) === '[object Boolean]') {\n        return 'click';\n      } else {\n        return reflex;\n      }\n    };\n\n    Tour.prototype._reposition = function($tip, step) {\n      var offsetBottom, offsetHeight, offsetRight, offsetWidth, originalLeft, originalTop, tipOffset;\n      offsetWidth = $tip[0].offsetWidth;\n      offsetHeight = $tip[0].offsetHeight;\n      tipOffset = $tip.offset();\n      originalLeft = tipOffset.left;\n      originalTop = tipOffset.top;\n      offsetBottom = $(document).outerHeight() - tipOffset.top - $tip.outerHeight();\n      if (offsetBottom < 0) {\n        tipOffset.top = tipOffset.top + offsetBottom;\n      }\n      offsetRight = $('html').outerWidth() - tipOffset.left - $tip.outerWidth();\n      if (offsetRight < 0) {\n        tipOffset.left = tipOffset.left + offsetRight;\n      }\n      if (tipOffset.top < 0) {\n        tipOffset.top = 0;\n      }\n      if (tipOffset.left < 0) {\n        tipOffset.left = 0;\n      }\n      $tip.offset(tipOffset);\n      if (step.placement === 'bottom' || step.placement === 'top') {\n        if (originalLeft !== tipOffset.left) {\n          return this._replaceArrow($tip, (tipOffset.left - originalLeft) * 2, offsetWidth, 'left');\n        }\n      } else {\n        if (originalTop !== tipOffset.top) {\n          return this._replaceArrow($tip, (tipOffset.top - originalTop) * 2, offsetHeight, 'top');\n        }\n      }\n    };\n\n    Tour.prototype._center = function($tip) {\n      return $tip.css('top', $(window).outerHeight() / 2 - $tip.outerHeight() / 2);\n    };\n\n    Tour.prototype._replaceArrow = function($tip, delta, dimension, position) {\n      return $tip.find('.arrow').css(position, delta ? 50 * (1 - delta / dimension) + '%' : '');\n    };\n\n    Tour.prototype._scrollIntoView = function(i) {\n      var $element, $window, counter, height, offsetTop, scrollTop, step, windowHeight;\n      step = this.getStep(i);\n      $element = $(step.element);\n      if (!$element.length) {\n        return this._showPopoverAndOverlay(i);\n      }\n      $window = $(window);\n      offsetTop = $element.offset().top;\n      height = $element.outerHeight();\n      windowHeight = $window.height();\n      scrollTop = 0;\n      switch (step.placement) {\n        case 'top':\n          scrollTop = Math.max(0, offsetTop - (windowHeight / 2));\n          break;\n        case 'left':\n        case 'right':\n          scrollTop = Math.max(0, (offsetTop + height / 2) - (windowHeight / 2));\n          break;\n        case 'bottom':\n          scrollTop = Math.max(0, (offsetTop + height) - (windowHeight / 2));\n      }\n      this._debug(\"Scroll into view. ScrollTop: \" + scrollTop + \". Element offset: \" + offsetTop + \". Window height: \" + windowHeight + \".\");\n      counter = 0;\n      return $('body, html').stop(true, true).animate({\n        scrollTop: Math.ceil(scrollTop)\n      }, (function(_this) {\n        return function() {\n          if (++counter === 2) {\n            _this._showPopoverAndOverlay(i);\n            return _this._debug(\"Scroll into view.\\nAnimation end element offset: \" + ($element.offset().top) + \".\\nWindow height: \" + ($window.height()) + \".\");\n          }\n        };\n      })(this));\n    };\n\n    Tour.prototype._onResize = function(callback, timeout) {\n      return $(window).on(\"resize.tour-\" + this._options.name, function() {\n        clearTimeout(timeout);\n        return timeout = setTimeout(callback, 100);\n      });\n    };\n\n    Tour.prototype._onScroll = function(callback, timeout) {\n      return $(window).on(\"scroll.tour-\" + this._options.name, function() {\n        clearTimeout(timeout);\n        return timeout = setTimeout(callback, 100);\n      });\n    };\n\n    Tour.prototype._initMouseNavigation = function() {\n      var _this;\n      _this = this;\n      return $(document).off(\"click.tour-\" + this._options.name, \".popover.tour-\" + this._options.name + \" *[data-role='prev']\").off(\"click.tour-\" + this._options.name, \".popover.tour-\" + this._options.name + \" *[data-role='next']\").off(\"click.tour-\" + this._options.name, \".popover.tour-\" + this._options.name + \" *[data-role='end']\").off(\"click.tour-\" + this._options.name, \".popover.tour-\" + this._options.name + \" *[data-role='pause-resume']\").on(\"click.tour-\" + this._options.name, \".popover.tour-\" + this._options.name + \" *[data-role='next']\", (function(_this) {\n        return function(e) {\n          e.preventDefault();\n          return _this.next();\n        };\n      })(this)).on(\"click.tour-\" + this._options.name, \".popover.tour-\" + this._options.name + \" *[data-role='prev']\", (function(_this) {\n        return function(e) {\n          e.preventDefault();\n          if (_this._current > 0) {\n            return _this.prev();\n          }\n        };\n      })(this)).on(\"click.tour-\" + this._options.name, \".popover.tour-\" + this._options.name + \" *[data-role='end']\", (function(_this) {\n        return function(e) {\n          e.preventDefault();\n          return _this.end();\n        };\n      })(this)).on(\"click.tour-\" + this._options.name, \".popover.tour-\" + this._options.name + \" *[data-role='pause-resume']\", function(e) {\n        var $this;\n        e.preventDefault();\n        $this = $(this);\n        $this.text(_this._paused ? $this.data('pause-text') : $this.data('resume-text'));\n        if (_this._paused) {\n          return _this.resume();\n        } else {\n          return _this.pause();\n        }\n      });\n    };\n\n    Tour.prototype._initKeyboardNavigation = function() {\n      if (!this._options.keyboard) {\n        return;\n      }\n      return $(document).on(\"keyup.tour-\" + this._options.name, (function(_this) {\n        return function(e) {\n          if (!e.which) {\n            return;\n          }\n          switch (e.which) {\n            case 39:\n              e.preventDefault();\n              if (_this._isLast()) {\n                return _this.next();\n              } else {\n                return _this.end();\n              }\n              break;\n            case 37:\n              e.preventDefault();\n              if (_this._current > 0) {\n                return _this.prev();\n              }\n          }\n        };\n      })(this));\n    };\n\n    Tour.prototype._makePromise = function(result) {\n      if (result && $.isFunction(result.then)) {\n        return result;\n      } else {\n        return null;\n      }\n    };\n\n    Tour.prototype._callOnPromiseDone = function(promise, cb, arg) {\n      if (promise) {\n        return promise.then((function(_this) {\n          return function(e) {\n            return cb.call(_this, arg);\n          };\n        })(this));\n      } else {\n        return cb.call(this, arg);\n      }\n    };\n\n    Tour.prototype._showBackground = function(step, data) {\n      var $backdrop, base, height, j, len, pos, ref, results, width;\n      height = $(document).height();\n      width = $(document).width();\n      ref = ['top', 'bottom', 'left', 'right'];\n      results = [];\n      for (j = 0, len = ref.length; j < len; j++) {\n        pos = ref[j];\n        $backdrop = (base = this.backdrops)[pos] != null ? base[pos] : base[pos] = $('<div>', {\n          \"class\": \"tour-backdrop \" + pos\n        });\n        $(step.backdropContainer).append($backdrop);\n        switch (pos) {\n          case 'top':\n            results.push($backdrop.height(data.offset.top > 0 ? data.offset.top : 0).width(width).offset({\n              top: 0,\n              left: 0\n            }));\n            break;\n          case 'bottom':\n            results.push($backdrop.offset({\n              top: data.offset.top + data.height,\n              left: 0\n            }).height(height - (data.offset.top + data.height)).width(width));\n            break;\n          case 'left':\n            results.push($backdrop.offset({\n              top: data.offset.top,\n              left: 0\n            }).height(data.height).width(data.offset.left > 0 ? data.offset.left : 0));\n            break;\n          case 'right':\n            results.push($backdrop.offset({\n              top: data.offset.top,\n              left: data.offset.left + data.width\n            }).height(data.height).width(width - (data.offset.left + data.width)));\n            break;\n          default:\n            results.push(void 0);\n        }\n      }\n      return results;\n    };\n\n    Tour.prototype._showOverlayElement = function(step) {\n      var $backdropElement, elementData;\n      $backdropElement = $(step.backdropElement);\n      if ($backdropElement.length === 0) {\n        elementData = {\n          width: 0,\n          height: 0,\n          offset: {\n            top: 0,\n            left: 0\n          }\n        };\n      } else {\n        elementData = {\n          width: $backdropElement.innerWidth(),\n          height: $backdropElement.innerHeight(),\n          offset: $backdropElement.offset()\n        };\n        $backdropElement.addClass('tour-step-backdrop');\n        if (step.backdropPadding) {\n          elementData = this._applyBackdropPadding(step.backdropPadding, elementData);\n        }\n      }\n      return this._showBackground(step, elementData);\n    };\n\n    Tour.prototype._hideOverlayElement = function(step) {\n      var $backdrop, pos, ref;\n      $(step.backdropElement).removeClass('tour-step-backdrop');\n      ref = this.backdrops;\n      for (pos in ref) {\n        $backdrop = ref[pos];\n        if ($backdrop && $backdrop.remove !== void 0) {\n          $backdrop.remove();\n        }\n      }\n      return this.backdrops = [];\n    };\n\n    Tour.prototype._applyBackdropPadding = function(padding, data) {\n      if (typeof padding === 'object') {\n        if (padding.top == null) {\n          padding.top = 0;\n        }\n        if (padding.right == null) {\n          padding.right = 0;\n        }\n        if (padding.bottom == null) {\n          padding.bottom = 0;\n        }\n        if (padding.left == null) {\n          padding.left = 0;\n        }\n        data.offset.top = data.offset.top - padding.top;\n        data.offset.left = data.offset.left - padding.left;\n        data.width = data.width + padding.left + padding.right;\n        data.height = data.height + padding.top + padding.bottom;\n      } else {\n        data.offset.top = data.offset.top - padding;\n        data.offset.left = data.offset.left - padding;\n        data.width = data.width + (padding * 2);\n        data.height = data.height + (padding * 2);\n      }\n      return data;\n    };\n\n    Tour.prototype._clearTimer = function() {\n      window.clearTimeout(this._timer);\n      this._timer = null;\n      return this._duration = null;\n    };\n\n    Tour.prototype._getProtocol = function(url) {\n      url = url.split('://');\n      if (url.length > 1) {\n        return url[0];\n      } else {\n        return 'http';\n      }\n    };\n\n    Tour.prototype._getHost = function(url) {\n      url = url.split('//');\n      url = url.length > 1 ? url[1] : url[0];\n      return url.split('/')[0];\n    };\n\n    Tour.prototype._getPath = function(path) {\n      return path.replace(/\\/?$/, '').split('?')[0].split('#')[0];\n    };\n\n    Tour.prototype._getQuery = function(path) {\n      return this._getParams(path, '?');\n    };\n\n    Tour.prototype._getHash = function(path) {\n      return this._getParams(path, '#');\n    };\n\n    Tour.prototype._getParams = function(path, start) {\n      var j, len, param, params, paramsObject;\n      params = path.split(start);\n      if (params.length === 1) {\n        return {};\n      }\n      params = params[1].split('&');\n      paramsObject = {};\n      for (j = 0, len = params.length; j < len; j++) {\n        param = params[j];\n        param = param.split('=');\n        paramsObject[param[0]] = param[1] || '';\n      }\n      return paramsObject;\n    };\n\n    Tour.prototype._equal = function(obj1, obj2) {\n      var j, k, len, obj1Keys, obj2Keys, v;\n      if ({}.toString.call(obj1) === '[object Object]' && {}.toString.call(obj2) === '[object Object]') {\n        obj1Keys = Object.keys(obj1);\n        obj2Keys = Object.keys(obj2);\n        if (obj1Keys.length !== obj2Keys.length) {\n          return false;\n        }\n        for (k in obj1) {\n          v = obj1[k];\n          if (!this._equal(obj2[k], v)) {\n            return false;\n          }\n        }\n        return true;\n      } else if ({}.toString.call(obj1) === '[object Array]' && {}.toString.call(obj2) === '[object Array]') {\n        if (obj1.length !== obj2.length) {\n          return false;\n        }\n        for (k = j = 0, len = obj1.length; j < len; k = ++j) {\n          v = obj1[k];\n          if (!this._equal(v, obj2[k])) {\n            return false;\n          }\n        }\n        return true;\n      } else {\n        return obj1 === obj2;\n      }\n    };\n\n    return Tour;\n\n  })();\n  return Tour;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYy94Ri5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ib290c3RyYXAtdG91ci9idWlsZC9qcy9ib290c3RyYXAtdG91ci5qcz83M2ZjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogYm9vdHN0cmFwLXRvdXIgLSB2MC4xMS4wXG4gKiBodHRwOi8vYm9vdHN0cmFwdG91ci5jb21cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBVbHJpY2ggU29zc291XG4gKlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxudmFyIGJpbmQgPSBmdW5jdGlvbihmbiwgbWUpeyByZXR1cm4gZnVuY3Rpb24oKXsgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpOyB9OyB9O1xuXG4oZnVuY3Rpb24od2luZG93LCBmYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICByZXR1cm4gZGVmaW5lKFsnanF1ZXJ5J10sIGZ1bmN0aW9uKGpRdWVyeSkge1xuICAgICAgcmV0dXJuIHdpbmRvdy5Ub3VyID0gZmFjdG9yeShqUXVlcnkpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnanF1ZXJ5JykpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB3aW5kb3cuVG91ciA9IGZhY3Rvcnkod2luZG93LmpRdWVyeSk7XG4gIH1cbn0pKHdpbmRvdywgZnVuY3Rpb24oJCkge1xuICB2YXIgVG91ciwgZG9jdW1lbnQ7XG4gIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuICBUb3VyID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFRvdXIob3B0aW9ucykge1xuICAgICAgdGhpcy5fc2hvd1BvcG92ZXJBbmRPdmVybGF5ID0gYmluZCh0aGlzLl9zaG93UG9wb3ZlckFuZE92ZXJsYXksIHRoaXMpO1xuICAgICAgdmFyIHN0b3JhZ2U7XG4gICAgICB0cnkge1xuICAgICAgICBzdG9yYWdlID0gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHN0b3JhZ2UgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX29wdGlvbnMgPSAkLmV4dGVuZCh7XG4gICAgICAgIG5hbWU6ICd0b3VyJyxcbiAgICAgICAgc3RlcHM6IFtdLFxuICAgICAgICBjb250YWluZXI6ICdib2R5JyxcbiAgICAgICAgYXV0b3Njcm9sbDogdHJ1ZSxcbiAgICAgICAga2V5Ym9hcmQ6IHRydWUsXG4gICAgICAgIHN0b3JhZ2U6IHN0b3JhZ2UsXG4gICAgICAgIGRlYnVnOiBmYWxzZSxcbiAgICAgICAgYmFja2Ryb3A6IGZhbHNlLFxuICAgICAgICBiYWNrZHJvcENvbnRhaW5lcjogJ2JvZHknLFxuICAgICAgICBiYWNrZHJvcFBhZGRpbmc6IDAsXG4gICAgICAgIHJlZGlyZWN0OiB0cnVlLFxuICAgICAgICBvcnBoYW46IGZhbHNlLFxuICAgICAgICBkdXJhdGlvbjogZmFsc2UsXG4gICAgICAgIGRlbGF5OiBmYWxzZSxcbiAgICAgICAgYmFzZVBhdGg6ICcnLFxuICAgICAgICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJwb3BvdmVyXCIgcm9sZT1cInRvb2x0aXBcIj4gPGRpdiBjbGFzcz1cImFycm93XCI+PC9kaXY+IDxoMyBjbGFzcz1cInBvcG92ZXItdGl0bGVcIj48L2gzPiA8ZGl2IGNsYXNzPVwicG9wb3Zlci1jb250ZW50XCI+PC9kaXY+IDxkaXYgY2xhc3M9XCJwb3BvdmVyLW5hdmlnYXRpb25cIj4gPGRpdiBjbGFzcz1cImJ0bi1ncm91cFwiPiA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1zbSBidG4tZGVmYXVsdFwiIGRhdGEtcm9sZT1cInByZXZcIj4mbGFxdW87IFByZXY8L2J1dHRvbj4gPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tc20gYnRuLWRlZmF1bHRcIiBkYXRhLXJvbGU9XCJuZXh0XCI+TmV4dCAmcmFxdW87PC9idXR0b24+IDxidXR0b24gY2xhc3M9XCJidG4gYnRuLXNtIGJ0bi1kZWZhdWx0XCIgZGF0YS1yb2xlPVwicGF1c2UtcmVzdW1lXCIgZGF0YS1wYXVzZS10ZXh0PVwiUGF1c2VcIiBkYXRhLXJlc3VtZS10ZXh0PVwiUmVzdW1lXCI+UGF1c2U8L2J1dHRvbj4gPC9kaXY+IDxidXR0b24gY2xhc3M9XCJidG4gYnRuLXNtIGJ0bi1kZWZhdWx0XCIgZGF0YS1yb2xlPVwiZW5kXCI+RW5kIHRvdXI8L2J1dHRvbj4gPC9kaXY+IDwvZGl2PicsXG4gICAgICAgIGFmdGVyU2V0U3RhdGU6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHt9LFxuICAgICAgICBhZnRlckdldFN0YXRlOiBmdW5jdGlvbihrZXksIHZhbHVlKSB7fSxcbiAgICAgICAgYWZ0ZXJSZW1vdmVTdGF0ZTogZnVuY3Rpb24oa2V5KSB7fSxcbiAgICAgICAgb25TdGFydDogZnVuY3Rpb24odG91cikge30sXG4gICAgICAgIG9uRW5kOiBmdW5jdGlvbih0b3VyKSB7fSxcbiAgICAgICAgb25TaG93OiBmdW5jdGlvbih0b3VyKSB7fSxcbiAgICAgICAgb25TaG93bjogZnVuY3Rpb24odG91cikge30sXG4gICAgICAgIG9uSGlkZTogZnVuY3Rpb24odG91cikge30sXG4gICAgICAgIG9uSGlkZGVuOiBmdW5jdGlvbih0b3VyKSB7fSxcbiAgICAgICAgb25OZXh0OiBmdW5jdGlvbih0b3VyKSB7fSxcbiAgICAgICAgb25QcmV2OiBmdW5jdGlvbih0b3VyKSB7fSxcbiAgICAgICAgb25QYXVzZTogZnVuY3Rpb24odG91ciwgZHVyYXRpb24pIHt9LFxuICAgICAgICBvblJlc3VtZTogZnVuY3Rpb24odG91ciwgZHVyYXRpb24pIHt9LFxuICAgICAgICBvblJlZGlyZWN0RXJyb3I6IGZ1bmN0aW9uKHRvdXIpIHt9XG4gICAgICB9LCBvcHRpb25zKTtcbiAgICAgIHRoaXMuX2ZvcmNlID0gZmFsc2U7XG4gICAgICB0aGlzLl9pbml0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2N1cnJlbnQgPSBudWxsO1xuICAgICAgdGhpcy5iYWNrZHJvcHMgPSBbXTtcbiAgICAgIHRoaXM7XG4gICAgfVxuXG4gICAgVG91ci5wcm90b3R5cGUuYWRkU3RlcHMgPSBmdW5jdGlvbihzdGVwcykge1xuICAgICAgdmFyIGosIGxlbiwgc3RlcDtcbiAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHN0ZXBzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgIHN0ZXAgPSBzdGVwc1tqXTtcbiAgICAgICAgdGhpcy5hZGRTdGVwKHN0ZXApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFRvdXIucHJvdG90eXBlLmFkZFN0ZXAgPSBmdW5jdGlvbihzdGVwKSB7XG4gICAgICB0aGlzLl9vcHRpb25zLnN0ZXBzLnB1c2goc3RlcCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgVG91ci5wcm90b3R5cGUuZ2V0U3RlcCA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgIGlmICh0aGlzLl9vcHRpb25zLnN0ZXBzW2ldICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICQuZXh0ZW5kKHtcbiAgICAgICAgICBpZDogXCJzdGVwLVwiICsgaSxcbiAgICAgICAgICBwYXRoOiAnJyxcbiAgICAgICAgICBob3N0OiAnJyxcbiAgICAgICAgICBwbGFjZW1lbnQ6ICdyaWdodCcsXG4gICAgICAgICAgdGl0bGU6ICcnLFxuICAgICAgICAgIGNvbnRlbnQ6ICc8cD48L3A+JyxcbiAgICAgICAgICBuZXh0OiBpID09PSB0aGlzLl9vcHRpb25zLnN0ZXBzLmxlbmd0aCAtIDEgPyAtMSA6IGkgKyAxLFxuICAgICAgICAgIHByZXY6IGkgLSAxLFxuICAgICAgICAgIGFuaW1hdGlvbjogdHJ1ZSxcbiAgICAgICAgICBjb250YWluZXI6IHRoaXMuX29wdGlvbnMuY29udGFpbmVyLFxuICAgICAgICAgIGF1dG9zY3JvbGw6IHRoaXMuX29wdGlvbnMuYXV0b3Njcm9sbCxcbiAgICAgICAgICBiYWNrZHJvcDogdGhpcy5fb3B0aW9ucy5iYWNrZHJvcCxcbiAgICAgICAgICBiYWNrZHJvcENvbnRhaW5lcjogdGhpcy5fb3B0aW9ucy5iYWNrZHJvcENvbnRhaW5lcixcbiAgICAgICAgICBiYWNrZHJvcFBhZGRpbmc6IHRoaXMuX29wdGlvbnMuYmFja2Ryb3BQYWRkaW5nLFxuICAgICAgICAgIHJlZGlyZWN0OiB0aGlzLl9vcHRpb25zLnJlZGlyZWN0LFxuICAgICAgICAgIHJlZmxleEVsZW1lbnQ6IHRoaXMuX29wdGlvbnMuc3RlcHNbaV0uZWxlbWVudCxcbiAgICAgICAgICBiYWNrZHJvcEVsZW1lbnQ6IHRoaXMuX29wdGlvbnMuc3RlcHNbaV0uZWxlbWVudCxcbiAgICAgICAgICBvcnBoYW46IHRoaXMuX29wdGlvbnMub3JwaGFuLFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLl9vcHRpb25zLmR1cmF0aW9uLFxuICAgICAgICAgIGRlbGF5OiB0aGlzLl9vcHRpb25zLmRlbGF5LFxuICAgICAgICAgIHRlbXBsYXRlOiB0aGlzLl9vcHRpb25zLnRlbXBsYXRlLFxuICAgICAgICAgIG9uU2hvdzogdGhpcy5fb3B0aW9ucy5vblNob3csXG4gICAgICAgICAgb25TaG93bjogdGhpcy5fb3B0aW9ucy5vblNob3duLFxuICAgICAgICAgIG9uSGlkZTogdGhpcy5fb3B0aW9ucy5vbkhpZGUsXG4gICAgICAgICAgb25IaWRkZW46IHRoaXMuX29wdGlvbnMub25IaWRkZW4sXG4gICAgICAgICAgb25OZXh0OiB0aGlzLl9vcHRpb25zLm9uTmV4dCxcbiAgICAgICAgICBvblByZXY6IHRoaXMuX29wdGlvbnMub25QcmV2LFxuICAgICAgICAgIG9uUGF1c2U6IHRoaXMuX29wdGlvbnMub25QYXVzZSxcbiAgICAgICAgICBvblJlc3VtZTogdGhpcy5fb3B0aW9ucy5vblJlc3VtZSxcbiAgICAgICAgICBvblJlZGlyZWN0RXJyb3I6IHRoaXMuX29wdGlvbnMub25SZWRpcmVjdEVycm9yXG4gICAgICAgIH0sIHRoaXMuX29wdGlvbnMuc3RlcHNbaV0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBUb3VyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oZm9yY2UpIHtcbiAgICAgIHRoaXMuX2ZvcmNlID0gZm9yY2U7XG4gICAgICBpZiAodGhpcy5lbmRlZCgpKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCdUb3VyIGVuZGVkLCBpbml0IHByZXZlbnRlZC4nKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB0aGlzLnNldEN1cnJlbnRTdGVwKCk7XG4gICAgICB0aGlzLl9pbml0TW91c2VOYXZpZ2F0aW9uKCk7XG4gICAgICB0aGlzLl9pbml0S2V5Ym9hcmROYXZpZ2F0aW9uKCk7XG4gICAgICB0aGlzLl9vblJlc2l6ZSgoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5zaG93U3RlcChfdGhpcy5fY3VycmVudCk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgICB0aGlzLl9vblNjcm9sbCgoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5fc2hvd1BvcG92ZXJBbmRPdmVybGF5KF90aGlzLl9jdXJyZW50KTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICAgIGlmICh0aGlzLl9jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuc2hvd1N0ZXAodGhpcy5fY3VycmVudCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9pbml0ZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFRvdXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oZm9yY2UpIHtcbiAgICAgIHZhciBwcm9taXNlO1xuICAgICAgaWYgKGZvcmNlID09IG51bGwpIHtcbiAgICAgICAgZm9yY2UgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5faW5pdGVkKSB7XG4gICAgICAgIHRoaXMuaW5pdChmb3JjZSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICBwcm9taXNlID0gdGhpcy5fbWFrZVByb21pc2UodGhpcy5fb3B0aW9ucy5vblN0YXJ0ICE9IG51bGwgPyB0aGlzLl9vcHRpb25zLm9uU3RhcnQodGhpcykgOiB2b2lkIDApO1xuICAgICAgICB0aGlzLl9jYWxsT25Qcm9taXNlRG9uZShwcm9taXNlLCB0aGlzLnNob3dTdGVwLCAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBUb3VyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcHJvbWlzZTtcbiAgICAgIHByb21pc2UgPSB0aGlzLmhpZGVTdGVwKHRoaXMuX2N1cnJlbnQsIHRoaXMuX2N1cnJlbnQgKyAxKTtcbiAgICAgIHJldHVybiB0aGlzLl9jYWxsT25Qcm9taXNlRG9uZShwcm9taXNlLCB0aGlzLl9zaG93TmV4dFN0ZXApO1xuICAgIH07XG5cbiAgICBUb3VyLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcHJvbWlzZTtcbiAgICAgIHByb21pc2UgPSB0aGlzLmhpZGVTdGVwKHRoaXMuX2N1cnJlbnQsIHRoaXMuX2N1cnJlbnQgLSAxKTtcbiAgICAgIHJldHVybiB0aGlzLl9jYWxsT25Qcm9taXNlRG9uZShwcm9taXNlLCB0aGlzLl9zaG93UHJldlN0ZXApO1xuICAgIH07XG5cbiAgICBUb3VyLnByb3RvdHlwZS5nb1RvID0gZnVuY3Rpb24oaSkge1xuICAgICAgdmFyIHByb21pc2U7XG4gICAgICBwcm9taXNlID0gdGhpcy5oaWRlU3RlcCh0aGlzLl9jdXJyZW50LCBpKTtcbiAgICAgIHJldHVybiB0aGlzLl9jYWxsT25Qcm9taXNlRG9uZShwcm9taXNlLCB0aGlzLnNob3dTdGVwLCBpKTtcbiAgICB9O1xuXG4gICAgVG91ci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZW5kSGVscGVyLCBwcm9taXNlO1xuICAgICAgZW5kSGVscGVyID0gKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgJChkb2N1bWVudCkub2ZmKFwiY2xpY2sudG91ci1cIiArIF90aGlzLl9vcHRpb25zLm5hbWUpO1xuICAgICAgICAgICQoZG9jdW1lbnQpLm9mZihcImtleXVwLnRvdXItXCIgKyBfdGhpcy5fb3B0aW9ucy5uYW1lKTtcbiAgICAgICAgICAkKHdpbmRvdykub2ZmKFwicmVzaXplLnRvdXItXCIgKyBfdGhpcy5fb3B0aW9ucy5uYW1lKTtcbiAgICAgICAgICAkKHdpbmRvdykub2ZmKFwic2Nyb2xsLnRvdXItXCIgKyBfdGhpcy5fb3B0aW9ucy5uYW1lKTtcbiAgICAgICAgICBfdGhpcy5fc2V0U3RhdGUoJ2VuZCcsICd5ZXMnKTtcbiAgICAgICAgICBfdGhpcy5faW5pdGVkID0gZmFsc2U7XG4gICAgICAgICAgX3RoaXMuX2ZvcmNlID0gZmFsc2U7XG4gICAgICAgICAgX3RoaXMuX2NsZWFyVGltZXIoKTtcbiAgICAgICAgICBpZiAoX3RoaXMuX29wdGlvbnMub25FbmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9vcHRpb25zLm9uRW5kKF90aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKTtcbiAgICAgIHByb21pc2UgPSB0aGlzLmhpZGVTdGVwKHRoaXMuX2N1cnJlbnQpO1xuICAgICAgcmV0dXJuIHRoaXMuX2NhbGxPblByb21pc2VEb25lKHByb21pc2UsIGVuZEhlbHBlcik7XG4gICAgfTtcblxuICAgIFRvdXIucHJvdG90eXBlLmVuZGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXRoaXMuX2ZvcmNlICYmICEhdGhpcy5fZ2V0U3RhdGUoJ2VuZCcpO1xuICAgIH07XG5cbiAgICBUb3VyLnByb3RvdHlwZS5yZXN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9yZW1vdmVTdGF0ZSgnY3VycmVudF9zdGVwJyk7XG4gICAgICB0aGlzLl9yZW1vdmVTdGF0ZSgnZW5kJyk7XG4gICAgICB0aGlzLl9yZW1vdmVTdGF0ZSgncmVkaXJlY3RfdG8nKTtcbiAgICAgIHJldHVybiB0aGlzLnN0YXJ0KCk7XG4gICAgfTtcblxuICAgIFRvdXIucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIHN0ZXAgPSB0aGlzLmdldFN0ZXAodGhpcy5fY3VycmVudCk7XG4gICAgICBpZiAoIShzdGVwICYmIHN0ZXAuZHVyYXRpb24pKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2R1cmF0aW9uIC09IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdGhpcy5fc3RhcnQ7XG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgICAgIHRoaXMuX2RlYnVnKFwiUGF1c2VkL1N0b3BwZWQgc3RlcCBcIiArICh0aGlzLl9jdXJyZW50ICsgMSkgKyBcIiB0aW1lciAoXCIgKyB0aGlzLl9kdXJhdGlvbiArIFwiIHJlbWFpbmluZykuXCIpO1xuICAgICAgaWYgKHN0ZXAub25QYXVzZSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzdGVwLm9uUGF1c2UodGhpcywgdGhpcy5fZHVyYXRpb24pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBUb3VyLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgc3RlcCA9IHRoaXMuZ2V0U3RlcCh0aGlzLl9jdXJyZW50KTtcbiAgICAgIGlmICghKHN0ZXAgJiYgc3RlcC5kdXJhdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3N0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICB0aGlzLl9kdXJhdGlvbiA9IHRoaXMuX2R1cmF0aW9uIHx8IHN0ZXAuZHVyYXRpb247XG4gICAgICB0aGlzLl90aW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKF90aGlzLl9pc0xhc3QoKSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLm5leHQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmVuZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpLCB0aGlzLl9kdXJhdGlvbik7XG4gICAgICB0aGlzLl9kZWJ1ZyhcIlN0YXJ0ZWQgc3RlcCBcIiArICh0aGlzLl9jdXJyZW50ICsgMSkgKyBcIiB0aW1lciB3aXRoIGR1cmF0aW9uIFwiICsgdGhpcy5fZHVyYXRpb24pO1xuICAgICAgaWYgKChzdGVwLm9uUmVzdW1lICE9IG51bGwpICYmIHRoaXMuX2R1cmF0aW9uICE9PSBzdGVwLmR1cmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBzdGVwLm9uUmVzdW1lKHRoaXMsIHRoaXMuX2R1cmF0aW9uKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVG91ci5wcm90b3R5cGUuaGlkZVN0ZXAgPSBmdW5jdGlvbihpLCBpTmV4dCkge1xuICAgICAgdmFyIGhpZGVEZWxheSwgaGlkZVN0ZXBIZWxwZXIsIHByb21pc2UsIHN0ZXA7XG4gICAgICBzdGVwID0gdGhpcy5nZXRTdGVwKGkpO1xuICAgICAgaWYgKCFzdGVwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NsZWFyVGltZXIoKTtcbiAgICAgIHByb21pc2UgPSB0aGlzLl9tYWtlUHJvbWlzZShzdGVwLm9uSGlkZSAhPSBudWxsID8gc3RlcC5vbkhpZGUodGhpcywgaSkgOiB2b2lkIDApO1xuICAgICAgaGlkZVN0ZXBIZWxwZXIgPSAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICB2YXIgJGVsZW1lbnQsIG5leHRfc3RlcDtcbiAgICAgICAgICAkZWxlbWVudCA9ICQoc3RlcC5lbGVtZW50KTtcbiAgICAgICAgICBpZiAoISgkZWxlbWVudC5kYXRhKCdicy5wb3BvdmVyJykgfHwgJGVsZW1lbnQuZGF0YSgncG9wb3ZlcicpKSkge1xuICAgICAgICAgICAgJGVsZW1lbnQgPSAkKCdib2R5Jyk7XG4gICAgICAgICAgfVxuICAgICAgICAgICRlbGVtZW50LnBvcG92ZXIoJ2Rlc3Ryb3knKS5yZW1vdmVDbGFzcyhcInRvdXItXCIgKyBfdGhpcy5fb3B0aW9ucy5uYW1lICsgXCItZWxlbWVudCB0b3VyLVwiICsgX3RoaXMuX29wdGlvbnMubmFtZSArIFwiLVwiICsgaSArIFwiLWVsZW1lbnRcIikucmVtb3ZlRGF0YSgnYnMucG9wb3ZlcicpO1xuICAgICAgICAgIGlmIChzdGVwLnJlZmxleCkge1xuICAgICAgICAgICAgJChzdGVwLnJlZmxleEVsZW1lbnQpLnJlbW92ZUNsYXNzKCd0b3VyLXN0ZXAtZWxlbWVudC1yZWZsZXgnKS5vZmYoKF90aGlzLl9yZWZsZXhFdmVudChzdGVwLnJlZmxleCkpICsgXCIudG91ci1cIiArIF90aGlzLl9vcHRpb25zLm5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RlcC5iYWNrZHJvcCkge1xuICAgICAgICAgICAgbmV4dF9zdGVwID0gKGlOZXh0ICE9IG51bGwpICYmIF90aGlzLmdldFN0ZXAoaU5leHQpO1xuICAgICAgICAgICAgaWYgKCFuZXh0X3N0ZXAgfHwgIW5leHRfc3RlcC5iYWNrZHJvcCB8fCBuZXh0X3N0ZXAuYmFja2Ryb3BFbGVtZW50ICE9PSBzdGVwLmJhY2tkcm9wRWxlbWVudCkge1xuICAgICAgICAgICAgICBfdGhpcy5faGlkZU92ZXJsYXlFbGVtZW50KHN0ZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RlcC5vbkhpZGRlbiAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RlcC5vbkhpZGRlbihfdGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSkodGhpcyk7XG4gICAgICBoaWRlRGVsYXkgPSBzdGVwLmRlbGF5LmhpZGUgfHwgc3RlcC5kZWxheTtcbiAgICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGhpZGVEZWxheSkgPT09ICdbb2JqZWN0IE51bWJlcl0nICYmIGhpZGVEZWxheSA+IDApIHtcbiAgICAgICAgdGhpcy5fZGVidWcoXCJXYWl0IFwiICsgaGlkZURlbGF5ICsgXCIgbWlsbGlzZWNvbmRzIHRvIGhpZGUgdGhlIHN0ZXAgXCIgKyAodGhpcy5fY3VycmVudCArIDEpKTtcbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9jYWxsT25Qcm9taXNlRG9uZShwcm9taXNlLCBoaWRlU3RlcEhlbHBlcik7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcyksIGhpZGVEZWxheSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jYWxsT25Qcm9taXNlRG9uZShwcm9taXNlLCBoaWRlU3RlcEhlbHBlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuXG4gICAgVG91ci5wcm90b3R5cGUuc2hvd1N0ZXAgPSBmdW5jdGlvbihpKSB7XG4gICAgICB2YXIgcGF0aCwgcHJvbWlzZSwgc2hvd0RlbGF5LCBzaG93U3RlcEhlbHBlciwgc2tpcFRvUHJldmlvdXMsIHN0ZXA7XG4gICAgICBpZiAodGhpcy5lbmRlZCgpKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCdUb3VyIGVuZGVkLCBzaG93U3RlcCBwcmV2ZW50ZWQuJyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgc3RlcCA9IHRoaXMuZ2V0U3RlcChpKTtcbiAgICAgIGlmICghc3RlcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBza2lwVG9QcmV2aW91cyA9IGkgPCB0aGlzLl9jdXJyZW50O1xuICAgICAgcHJvbWlzZSA9IHRoaXMuX21ha2VQcm9taXNlKHN0ZXAub25TaG93ICE9IG51bGwgPyBzdGVwLm9uU2hvdyh0aGlzLCBpKSA6IHZvaWQgMCk7XG4gICAgICB0aGlzLnNldEN1cnJlbnRTdGVwKGkpO1xuICAgICAgcGF0aCA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgc3dpdGNoICh7fS50b1N0cmluZy5jYWxsKHN0ZXAucGF0aCkpIHtcbiAgICAgICAgICBjYXNlICdbb2JqZWN0IEZ1bmN0aW9uXSc6XG4gICAgICAgICAgICByZXR1cm4gc3RlcC5wYXRoKCk7XG4gICAgICAgICAgY2FzZSAnW29iamVjdCBTdHJpbmddJzpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zLmJhc2VQYXRoICsgc3RlcC5wYXRoO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gc3RlcC5wYXRoO1xuICAgICAgICB9XG4gICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgaWYgKHN0ZXAucmVkaXJlY3QgJiYgdGhpcy5faXNSZWRpcmVjdChzdGVwLmhvc3QsIHBhdGgsIGRvY3VtZW50LmxvY2F0aW9uKSkge1xuICAgICAgICB0aGlzLl9yZWRpcmVjdChzdGVwLCBpLCBwYXRoKTtcbiAgICAgICAgaWYgKCF0aGlzLl9pc0p1c3RQYXRoSGFzaERpZmZlcmVudChzdGVwLmhvc3QsIHBhdGgsIGRvY3VtZW50LmxvY2F0aW9uKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2hvd1N0ZXBIZWxwZXIgPSAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBpZiAoX3RoaXMuX2lzT3JwaGFuKHN0ZXApKSB7XG4gICAgICAgICAgICBpZiAoc3RlcC5vcnBoYW4gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIF90aGlzLl9kZWJ1ZyhcIlNraXAgdGhlIG9ycGhhbiBzdGVwIFwiICsgKF90aGlzLl9jdXJyZW50ICsgMSkgKyBcIi5cXG5PcnBoYW4gb3B0aW9uIGlzIGZhbHNlIGFuZCB0aGUgZWxlbWVudCBkb2VzIG5vdCBleGlzdCBvciBpcyBoaWRkZW4uXCIpO1xuICAgICAgICAgICAgICBpZiAoc2tpcFRvUHJldmlvdXMpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fc2hvd1ByZXZTdGVwKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3Nob3dOZXh0U3RlcCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLl9kZWJ1ZyhcIlNob3cgdGhlIG9ycGhhbiBzdGVwIFwiICsgKF90aGlzLl9jdXJyZW50ICsgMSkgKyBcIi4gT3JwaGFucyBvcHRpb24gaXMgdHJ1ZS5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGVwLmF1dG9zY3JvbGwpIHtcbiAgICAgICAgICAgIF90aGlzLl9zY3JvbGxJbnRvVmlldyhpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3RoaXMuX3Nob3dQb3BvdmVyQW5kT3ZlcmxheShpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0ZXAuZHVyYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5yZXN1bWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKTtcbiAgICAgIHNob3dEZWxheSA9IHN0ZXAuZGVsYXkuc2hvdyB8fCBzdGVwLmRlbGF5O1xuICAgICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoc2hvd0RlbGF5KSA9PT0gJ1tvYmplY3QgTnVtYmVyXScgJiYgc2hvd0RlbGF5ID4gMCkge1xuICAgICAgICB0aGlzLl9kZWJ1ZyhcIldhaXQgXCIgKyBzaG93RGVsYXkgKyBcIiBtaWxsaXNlY29uZHMgdG8gc2hvdyB0aGUgc3RlcCBcIiArICh0aGlzLl9jdXJyZW50ICsgMSkpO1xuICAgICAgICB3aW5kb3cuc2V0VGltZW91dCgoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX2NhbGxPblByb21pc2VEb25lKHByb21pc2UsIHNob3dTdGVwSGVscGVyKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSwgc2hvd0RlbGF5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NhbGxPblByb21pc2VEb25lKHByb21pc2UsIHNob3dTdGVwSGVscGVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH07XG5cbiAgICBUb3VyLnByb3RvdHlwZS5nZXRDdXJyZW50U3RlcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnQ7XG4gICAgfTtcblxuICAgIFRvdXIucHJvdG90eXBlLnNldEN1cnJlbnRTdGVwID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnQgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fc2V0U3RhdGUoJ2N1cnJlbnRfc3RlcCcsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnQgPSB0aGlzLl9nZXRTdGF0ZSgnY3VycmVudF9zdGVwJyk7XG4gICAgICAgIHRoaXMuX2N1cnJlbnQgPSB0aGlzLl9jdXJyZW50ID09PSBudWxsID8gbnVsbCA6IHBhcnNlSW50KHRoaXMuX2N1cnJlbnQsIDEwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBUb3VyLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zaG93T3ZlcmxheUVsZW1lbnQodGhpcy5nZXRTdGVwKHRoaXMuZ2V0Q3VycmVudFN0ZXAoKSkpO1xuICAgIH07XG5cbiAgICBUb3VyLnByb3RvdHlwZS5fc2V0U3RhdGUgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgZSwga2V5TmFtZTtcbiAgICAgIGlmICh0aGlzLl9vcHRpb25zLnN0b3JhZ2UpIHtcbiAgICAgICAga2V5TmFtZSA9IHRoaXMuX29wdGlvbnMubmFtZSArIFwiX1wiICsga2V5O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuX29wdGlvbnMuc3RvcmFnZS5zZXRJdGVtKGtleU5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBlID0gZXJyb3I7XG4gICAgICAgICAgaWYgKGUuY29kZSA9PT0gRE9NRXhjZXB0aW9uLlFVT1RBX0VYQ0VFREVEX0VSUikge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoJ0xvY2FsU3RvcmFnZSBxdW90YSBleGNlZWRlZC4gU3RhdGUgc3RvcmFnZSBmYWlsZWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zLmFmdGVyU2V0U3RhdGUoa2V5TmFtZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlID09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLl9zdGF0ZSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZVtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFRvdXIucHJvdG90eXBlLl9yZW1vdmVTdGF0ZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIGtleU5hbWU7XG4gICAgICBpZiAodGhpcy5fb3B0aW9ucy5zdG9yYWdlKSB7XG4gICAgICAgIGtleU5hbWUgPSB0aGlzLl9vcHRpb25zLm5hbWUgKyBcIl9cIiArIGtleTtcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5zdG9yYWdlLnJlbW92ZUl0ZW0oa2V5TmFtZSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zLmFmdGVyUmVtb3ZlU3RhdGUoa2V5TmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUgIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBkZWxldGUgdGhpcy5fc3RhdGVba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBUb3VyLnByb3RvdHlwZS5fZ2V0U3RhdGUgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHZhciBrZXlOYW1lLCB2YWx1ZTtcbiAgICAgIGlmICh0aGlzLl9vcHRpb25zLnN0b3JhZ2UpIHtcbiAgICAgICAga2V5TmFtZSA9IHRoaXMuX29wdGlvbnMubmFtZSArIFwiX1wiICsga2V5O1xuICAgICAgICB2YWx1ZSA9IHRoaXMuX29wdGlvbnMuc3RvcmFnZS5nZXRJdGVtKGtleU5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlICE9IG51bGwpIHtcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMuX3N0YXRlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwIHx8IHZhbHVlID09PSAnbnVsbCcpIHtcbiAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5fb3B0aW9ucy5hZnRlckdldFN0YXRlKGtleSwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG5cbiAgICBUb3VyLnByb3RvdHlwZS5fc2hvd05leHRTdGVwID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcHJvbWlzZSwgc2hvd05leHRTdGVwSGVscGVyLCBzdGVwO1xuICAgICAgc3RlcCA9IHRoaXMuZ2V0U3RlcCh0aGlzLl9jdXJyZW50KTtcbiAgICAgIHNob3dOZXh0U3RlcEhlbHBlciA9IChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5zaG93U3RlcChzdGVwLm5leHQpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcyk7XG4gICAgICBwcm9taXNlID0gdGhpcy5fbWFrZVByb21pc2Uoc3RlcC5vbk5leHQgIT0gbnVsbCA/IHN0ZXAub25OZXh0KHRoaXMpIDogdm9pZCAwKTtcbiAgICAgIHJldHVybiB0aGlzLl9jYWxsT25Qcm9taXNlRG9uZShwcm9taXNlLCBzaG93TmV4dFN0ZXBIZWxwZXIpO1xuICAgIH07XG5cbiAgICBUb3VyLnByb3RvdHlwZS5fc2hvd1ByZXZTdGVwID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcHJvbWlzZSwgc2hvd1ByZXZTdGVwSGVscGVyLCBzdGVwO1xuICAgICAgc3RlcCA9IHRoaXMuZ2V0U3RlcCh0aGlzLl9jdXJyZW50KTtcbiAgICAgIHNob3dQcmV2U3RlcEhlbHBlciA9IChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5zaG93U3RlcChzdGVwLnByZXYpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcyk7XG4gICAgICBwcm9taXNlID0gdGhpcy5fbWFrZVByb21pc2Uoc3RlcC5vblByZXYgIT0gbnVsbCA/IHN0ZXAub25QcmV2KHRoaXMpIDogdm9pZCAwKTtcbiAgICAgIHJldHVybiB0aGlzLl9jYWxsT25Qcm9taXNlRG9uZShwcm9taXNlLCBzaG93UHJldlN0ZXBIZWxwZXIpO1xuICAgIH07XG5cbiAgICBUb3VyLnByb3RvdHlwZS5fZGVidWcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICBpZiAodGhpcy5fb3B0aW9ucy5kZWJ1Zykge1xuICAgICAgICByZXR1cm4gd2luZG93LmNvbnNvbGUubG9nKFwiQm9vdHN0cmFwIFRvdXIgJ1wiICsgdGhpcy5fb3B0aW9ucy5uYW1lICsgXCInIHwgXCIgKyB0ZXh0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVG91ci5wcm90b3R5cGUuX2lzUmVkaXJlY3QgPSBmdW5jdGlvbihob3N0LCBwYXRoLCBsb2NhdGlvbikge1xuICAgICAgdmFyIGN1cnJlbnRQYXRoO1xuICAgICAgaWYgKChob3N0ICE9IG51bGwpICYmIGhvc3QgIT09ICcnICYmICgoe30udG9TdHJpbmcuY2FsbChob3N0KSA9PT0gJ1tvYmplY3QgUmVnRXhwXScgJiYgIWhvc3QudGVzdChsb2NhdGlvbi5vcmlnaW4pKSB8fCAoe30udG9TdHJpbmcuY2FsbChob3N0KSA9PT0gJ1tvYmplY3QgU3RyaW5nXScgJiYgdGhpcy5faXNIb3N0RGlmZmVyZW50KGhvc3QsIGxvY2F0aW9uKSkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgY3VycmVudFBhdGggPSBbbG9jYXRpb24ucGF0aG5hbWUsIGxvY2F0aW9uLnNlYXJjaCwgbG9jYXRpb24uaGFzaF0uam9pbignJyk7XG4gICAgICByZXR1cm4gKHBhdGggIT0gbnVsbCkgJiYgcGF0aCAhPT0gJycgJiYgKCh7fS50b1N0cmluZy5jYWxsKHBhdGgpID09PSAnW29iamVjdCBSZWdFeHBdJyAmJiAhcGF0aC50ZXN0KGN1cnJlbnRQYXRoKSkgfHwgKHt9LnRvU3RyaW5nLmNhbGwocGF0aCkgPT09ICdbb2JqZWN0IFN0cmluZ10nICYmIHRoaXMuX2lzUGF0aERpZmZlcmVudChwYXRoLCBjdXJyZW50UGF0aCkpKTtcbiAgICB9O1xuXG4gICAgVG91ci5wcm90b3R5cGUuX2lzSG9zdERpZmZlcmVudCA9IGZ1bmN0aW9uKGhvc3QsIGxvY2F0aW9uKSB7XG4gICAgICBzd2l0Y2ggKHt9LnRvU3RyaW5nLmNhbGwoaG9zdCkpIHtcbiAgICAgICAgY2FzZSAnW29iamVjdCBSZWdFeHBdJzpcbiAgICAgICAgICByZXR1cm4gIWhvc3QudGVzdChsb2NhdGlvbi5vcmlnaW4pO1xuICAgICAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRQcm90b2NvbChob3N0KSAhPT0gdGhpcy5fZ2V0UHJvdG9jb2wobG9jYXRpb24uaHJlZikgfHwgdGhpcy5fZ2V0SG9zdChob3N0KSAhPT0gdGhpcy5fZ2V0SG9zdChsb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVG91ci5wcm90b3R5cGUuX2lzUGF0aERpZmZlcmVudCA9IGZ1bmN0aW9uKHBhdGgsIGN1cnJlbnRQYXRoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0UGF0aChwYXRoKSAhPT0gdGhpcy5fZ2V0UGF0aChjdXJyZW50UGF0aCkgfHwgIXRoaXMuX2VxdWFsKHRoaXMuX2dldFF1ZXJ5KHBhdGgpLCB0aGlzLl9nZXRRdWVyeShjdXJyZW50UGF0aCkpIHx8ICF0aGlzLl9lcXVhbCh0aGlzLl9nZXRIYXNoKHBhdGgpLCB0aGlzLl9nZXRIYXNoKGN1cnJlbnRQYXRoKSk7XG4gICAgfTtcblxuICAgIFRvdXIucHJvdG90eXBlLl9pc0p1c3RQYXRoSGFzaERpZmZlcmVudCA9IGZ1bmN0aW9uKGhvc3QsIHBhdGgsIGxvY2F0aW9uKSB7XG4gICAgICB2YXIgY3VycmVudFBhdGg7XG4gICAgICBpZiAoKGhvc3QgIT0gbnVsbCkgJiYgaG9zdCAhPT0gJycpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzSG9zdERpZmZlcmVudChob3N0LCBsb2NhdGlvbikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN1cnJlbnRQYXRoID0gW2xvY2F0aW9uLnBhdGhuYW1lLCBsb2NhdGlvbi5zZWFyY2gsIGxvY2F0aW9uLmhhc2hdLmpvaW4oJycpO1xuICAgICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwocGF0aCkgPT09ICdbb2JqZWN0IFN0cmluZ10nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRQYXRoKHBhdGgpID09PSB0aGlzLl9nZXRQYXRoKGN1cnJlbnRQYXRoKSAmJiB0aGlzLl9lcXVhbCh0aGlzLl9nZXRRdWVyeShwYXRoKSwgdGhpcy5fZ2V0UXVlcnkoY3VycmVudFBhdGgpKSAmJiAhdGhpcy5fZXF1YWwodGhpcy5fZ2V0SGFzaChwYXRoKSwgdGhpcy5fZ2V0SGFzaChjdXJyZW50UGF0aCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBUb3VyLnByb3RvdHlwZS5fcmVkaXJlY3QgPSBmdW5jdGlvbihzdGVwLCBpLCBwYXRoKSB7XG4gICAgICB2YXIgaHJlZjtcbiAgICAgIGlmICgkLmlzRnVuY3Rpb24oc3RlcC5yZWRpcmVjdCkpIHtcbiAgICAgICAgcmV0dXJuIHN0ZXAucmVkaXJlY3QuY2FsbCh0aGlzLCBwYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhyZWYgPSB7fS50b1N0cmluZy5jYWxsKHN0ZXAuaG9zdCkgPT09ICdbb2JqZWN0IFN0cmluZ10nID8gXCJcIiArIHN0ZXAuaG9zdCArIHBhdGggOiBwYXRoO1xuICAgICAgICB0aGlzLl9kZWJ1ZyhcIlJlZGlyZWN0IHRvIFwiICsgaHJlZik7XG4gICAgICAgIGlmICh0aGlzLl9nZXRTdGF0ZSgncmVkaXJlY3RfdG8nKSA9PT0gKFwiXCIgKyBpKSkge1xuICAgICAgICAgIHRoaXMuX2RlYnVnKFwiRXJyb3IgcmVkaXJlY3Rpb24gbG9vcCB0byBcIiArIHBhdGgpO1xuICAgICAgICAgIHRoaXMuX3JlbW92ZVN0YXRlKCdyZWRpcmVjdF90bycpO1xuICAgICAgICAgIGlmIChzdGVwLm9uUmVkaXJlY3RFcnJvciAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RlcC5vblJlZGlyZWN0RXJyb3IodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3NldFN0YXRlKCdyZWRpcmVjdF90bycsIFwiXCIgKyBpKTtcbiAgICAgICAgICByZXR1cm4gZG9jdW1lbnQubG9jYXRpb24uaHJlZiA9IGhyZWY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVG91ci5wcm90b3R5cGUuX2lzT3JwaGFuID0gZnVuY3Rpb24oc3RlcCkge1xuICAgICAgcmV0dXJuIChzdGVwLmVsZW1lbnQgPT0gbnVsbCkgfHwgISQoc3RlcC5lbGVtZW50KS5sZW5ndGggfHwgJChzdGVwLmVsZW1lbnQpLmlzKCc6aGlkZGVuJykgJiYgKCQoc3RlcC5lbGVtZW50KVswXS5uYW1lc3BhY2VVUkkgIT09ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycpO1xuICAgIH07XG5cbiAgICBUb3VyLnByb3RvdHlwZS5faXNMYXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY3VycmVudCA8IHRoaXMuX29wdGlvbnMuc3RlcHMubGVuZ3RoIC0gMTtcbiAgICB9O1xuXG4gICAgVG91ci5wcm90b3R5cGUuX3Nob3dQb3BvdmVyQW5kT3ZlcmxheSA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgaWYgKHRoaXMuZ2V0Q3VycmVudFN0ZXAoKSAhPT0gaSB8fCB0aGlzLmVuZGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3RlcCA9IHRoaXMuZ2V0U3RlcChpKTtcbiAgICAgIGlmIChzdGVwLmJhY2tkcm9wKSB7XG4gICAgICAgIHRoaXMuX3Nob3dPdmVybGF5RWxlbWVudChzdGVwKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3Nob3dQb3BvdmVyKHN0ZXAsIGkpO1xuICAgICAgaWYgKHN0ZXAub25TaG93biAhPSBudWxsKSB7XG4gICAgICAgIHN0ZXAub25TaG93bih0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9kZWJ1ZyhcIlN0ZXAgXCIgKyAodGhpcy5fY3VycmVudCArIDEpICsgXCIgb2YgXCIgKyB0aGlzLl9vcHRpb25zLnN0ZXBzLmxlbmd0aCk7XG4gICAgfTtcblxuICAgIFRvdXIucHJvdG90eXBlLl9zaG93UG9wb3ZlciA9IGZ1bmN0aW9uKHN0ZXAsIGkpIHtcbiAgICAgIHZhciAkZWxlbWVudCwgJHRpcCwgaXNPcnBoYW4sIG9wdGlvbnMsIHNob3VsZEFkZFNtYXJ0O1xuICAgICAgJChcIi50b3VyLVwiICsgdGhpcy5fb3B0aW9ucy5uYW1lKS5yZW1vdmUoKTtcbiAgICAgIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgdGhpcy5fb3B0aW9ucyk7XG4gICAgICBpc09ycGhhbiA9IHRoaXMuX2lzT3JwaGFuKHN0ZXApO1xuICAgICAgc3RlcC50ZW1wbGF0ZSA9IHRoaXMuX3RlbXBsYXRlKHN0ZXAsIGkpO1xuICAgICAgaWYgKGlzT3JwaGFuKSB7XG4gICAgICAgIHN0ZXAuZWxlbWVudCA9ICdib2R5JztcbiAgICAgICAgc3RlcC5wbGFjZW1lbnQgPSAndG9wJztcbiAgICAgIH1cbiAgICAgICRlbGVtZW50ID0gJChzdGVwLmVsZW1lbnQpO1xuICAgICAgJGVsZW1lbnQuYWRkQ2xhc3MoXCJ0b3VyLVwiICsgdGhpcy5fb3B0aW9ucy5uYW1lICsgXCItZWxlbWVudCB0b3VyLVwiICsgdGhpcy5fb3B0aW9ucy5uYW1lICsgXCItXCIgKyBpICsgXCItZWxlbWVudFwiKTtcbiAgICAgIGlmIChzdGVwLm9wdGlvbnMpIHtcbiAgICAgICAgJC5leHRlbmQob3B0aW9ucywgc3RlcC5vcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGVwLnJlZmxleCAmJiAhaXNPcnBoYW4pIHtcbiAgICAgICAgJChzdGVwLnJlZmxleEVsZW1lbnQpLmFkZENsYXNzKCd0b3VyLXN0ZXAtZWxlbWVudC1yZWZsZXgnKS5vZmYoKHRoaXMuX3JlZmxleEV2ZW50KHN0ZXAucmVmbGV4KSkgKyBcIi50b3VyLVwiICsgdGhpcy5fb3B0aW9ucy5uYW1lKS5vbigodGhpcy5fcmVmbGV4RXZlbnQoc3RlcC5yZWZsZXgpKSArIFwiLnRvdXItXCIgKyB0aGlzLl9vcHRpb25zLm5hbWUsIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5faXNMYXN0KCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm5leHQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5lbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgICB9XG4gICAgICBzaG91bGRBZGRTbWFydCA9IHN0ZXAuc21hcnRQbGFjZW1lbnQgPT09IHRydWUgJiYgc3RlcC5wbGFjZW1lbnQuc2VhcmNoKC9hdXRvL2kpID09PSAtMTtcbiAgICAgICRlbGVtZW50LnBvcG92ZXIoe1xuICAgICAgICBwbGFjZW1lbnQ6IHNob3VsZEFkZFNtYXJ0ID8gXCJhdXRvIFwiICsgc3RlcC5wbGFjZW1lbnQgOiBzdGVwLnBsYWNlbWVudCxcbiAgICAgICAgdHJpZ2dlcjogJ21hbnVhbCcsXG4gICAgICAgIHRpdGxlOiBzdGVwLnRpdGxlLFxuICAgICAgICBjb250ZW50OiBzdGVwLmNvbnRlbnQsXG4gICAgICAgIGh0bWw6IHRydWUsXG4gICAgICAgIGFuaW1hdGlvbjogc3RlcC5hbmltYXRpb24sXG4gICAgICAgIGNvbnRhaW5lcjogc3RlcC5jb250YWluZXIsXG4gICAgICAgIHRlbXBsYXRlOiBzdGVwLnRlbXBsYXRlLFxuICAgICAgICBzZWxlY3Rvcjogc3RlcC5lbGVtZW50XG4gICAgICB9KS5wb3BvdmVyKCdzaG93Jyk7XG4gICAgICAkdGlwID0gJGVsZW1lbnQuZGF0YSgnYnMucG9wb3ZlcicpID8gJGVsZW1lbnQuZGF0YSgnYnMucG9wb3ZlcicpLnRpcCgpIDogJGVsZW1lbnQuZGF0YSgncG9wb3ZlcicpLnRpcCgpO1xuICAgICAgJHRpcC5hdHRyKCdpZCcsIHN0ZXAuaWQpO1xuICAgICAgaWYgKCRlbGVtZW50LmNzcygncG9zaXRpb24nKSA9PT0gJ2ZpeGVkJykge1xuICAgICAgICAkdGlwLmNzcygncG9zaXRpb24nLCAnZml4ZWQnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlcG9zaXRpb24oJHRpcCwgc3RlcCk7XG4gICAgICBpZiAoaXNPcnBoYW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NlbnRlcigkdGlwKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVG91ci5wcm90b3R5cGUuX3RlbXBsYXRlID0gZnVuY3Rpb24oc3RlcCwgaSkge1xuICAgICAgdmFyICRuYXZpZ2F0aW9uLCAkbmV4dCwgJHByZXYsICRyZXN1bWUsICR0ZW1wbGF0ZSwgdGVtcGxhdGU7XG4gICAgICB0ZW1wbGF0ZSA9IHN0ZXAudGVtcGxhdGU7XG4gICAgICBpZiAodGhpcy5faXNPcnBoYW4oc3RlcCkgJiYge30udG9TdHJpbmcuY2FsbChzdGVwLm9ycGhhbikgIT09ICdbb2JqZWN0IEJvb2xlYW5dJykge1xuICAgICAgICB0ZW1wbGF0ZSA9IHN0ZXAub3JwaGFuO1xuICAgICAgfVxuICAgICAgJHRlbXBsYXRlID0gJC5pc0Z1bmN0aW9uKHRlbXBsYXRlKSA/ICQodGVtcGxhdGUoaSwgc3RlcCkpIDogJCh0ZW1wbGF0ZSk7XG4gICAgICAkbmF2aWdhdGlvbiA9ICR0ZW1wbGF0ZS5maW5kKCcucG9wb3Zlci1uYXZpZ2F0aW9uJyk7XG4gICAgICAkcHJldiA9ICRuYXZpZ2F0aW9uLmZpbmQoJ1tkYXRhLXJvbGU9XCJwcmV2XCJdJyk7XG4gICAgICAkbmV4dCA9ICRuYXZpZ2F0aW9uLmZpbmQoJ1tkYXRhLXJvbGU9XCJuZXh0XCJdJyk7XG4gICAgICAkcmVzdW1lID0gJG5hdmlnYXRpb24uZmluZCgnW2RhdGEtcm9sZT1cInBhdXNlLXJlc3VtZVwiXScpO1xuICAgICAgaWYgKHRoaXMuX2lzT3JwaGFuKHN0ZXApKSB7XG4gICAgICAgICR0ZW1wbGF0ZS5hZGRDbGFzcygnb3JwaGFuJyk7XG4gICAgICB9XG4gICAgICAkdGVtcGxhdGUuYWRkQ2xhc3MoXCJ0b3VyLVwiICsgdGhpcy5fb3B0aW9ucy5uYW1lICsgXCIgdG91ci1cIiArIHRoaXMuX29wdGlvbnMubmFtZSArIFwiLVwiICsgaSk7XG4gICAgICBpZiAoc3RlcC5yZWZsZXgpIHtcbiAgICAgICAgJHRlbXBsYXRlLmFkZENsYXNzKFwidG91ci1cIiArIHRoaXMuX29wdGlvbnMubmFtZSArIFwiLXJlZmxleFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGVwLnByZXYgPCAwKSB7XG4gICAgICAgICRwcmV2LmFkZENsYXNzKCdkaXNhYmxlZCcpLnByb3AoJ2Rpc2FibGVkJywgdHJ1ZSkucHJvcCgndGFiaW5kZXgnLCAtMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RlcC5uZXh0IDwgMCkge1xuICAgICAgICAkbmV4dC5hZGRDbGFzcygnZGlzYWJsZWQnKS5wcm9wKCdkaXNhYmxlZCcsIHRydWUpLnByb3AoJ3RhYmluZGV4JywgLTEpO1xuICAgICAgfVxuICAgICAgaWYgKCFzdGVwLmR1cmF0aW9uKSB7XG4gICAgICAgICRyZXN1bWUucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gJHRlbXBsYXRlLmNsb25lKCkud3JhcCgnPGRpdj4nKS5wYXJlbnQoKS5odG1sKCk7XG4gICAgfTtcblxuICAgIFRvdXIucHJvdG90eXBlLl9yZWZsZXhFdmVudCA9IGZ1bmN0aW9uKHJlZmxleCkge1xuICAgICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwocmVmbGV4KSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nKSB7XG4gICAgICAgIHJldHVybiAnY2xpY2snO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlZmxleDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVG91ci5wcm90b3R5cGUuX3JlcG9zaXRpb24gPSBmdW5jdGlvbigkdGlwLCBzdGVwKSB7XG4gICAgICB2YXIgb2Zmc2V0Qm90dG9tLCBvZmZzZXRIZWlnaHQsIG9mZnNldFJpZ2h0LCBvZmZzZXRXaWR0aCwgb3JpZ2luYWxMZWZ0LCBvcmlnaW5hbFRvcCwgdGlwT2Zmc2V0O1xuICAgICAgb2Zmc2V0V2lkdGggPSAkdGlwWzBdLm9mZnNldFdpZHRoO1xuICAgICAgb2Zmc2V0SGVpZ2h0ID0gJHRpcFswXS5vZmZzZXRIZWlnaHQ7XG4gICAgICB0aXBPZmZzZXQgPSAkdGlwLm9mZnNldCgpO1xuICAgICAgb3JpZ2luYWxMZWZ0ID0gdGlwT2Zmc2V0LmxlZnQ7XG4gICAgICBvcmlnaW5hbFRvcCA9IHRpcE9mZnNldC50b3A7XG4gICAgICBvZmZzZXRCb3R0b20gPSAkKGRvY3VtZW50KS5vdXRlckhlaWdodCgpIC0gdGlwT2Zmc2V0LnRvcCAtICR0aXAub3V0ZXJIZWlnaHQoKTtcbiAgICAgIGlmIChvZmZzZXRCb3R0b20gPCAwKSB7XG4gICAgICAgIHRpcE9mZnNldC50b3AgPSB0aXBPZmZzZXQudG9wICsgb2Zmc2V0Qm90dG9tO1xuICAgICAgfVxuICAgICAgb2Zmc2V0UmlnaHQgPSAkKCdodG1sJykub3V0ZXJXaWR0aCgpIC0gdGlwT2Zmc2V0LmxlZnQgLSAkdGlwLm91dGVyV2lkdGgoKTtcbiAgICAgIGlmIChvZmZzZXRSaWdodCA8IDApIHtcbiAgICAgICAgdGlwT2Zmc2V0LmxlZnQgPSB0aXBPZmZzZXQubGVmdCArIG9mZnNldFJpZ2h0O1xuICAgICAgfVxuICAgICAgaWYgKHRpcE9mZnNldC50b3AgPCAwKSB7XG4gICAgICAgIHRpcE9mZnNldC50b3AgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKHRpcE9mZnNldC5sZWZ0IDwgMCkge1xuICAgICAgICB0aXBPZmZzZXQubGVmdCA9IDA7XG4gICAgICB9XG4gICAgICAkdGlwLm9mZnNldCh0aXBPZmZzZXQpO1xuICAgICAgaWYgKHN0ZXAucGxhY2VtZW50ID09PSAnYm90dG9tJyB8fCBzdGVwLnBsYWNlbWVudCA9PT0gJ3RvcCcpIHtcbiAgICAgICAgaWYgKG9yaWdpbmFsTGVmdCAhPT0gdGlwT2Zmc2V0LmxlZnQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fcmVwbGFjZUFycm93KCR0aXAsICh0aXBPZmZzZXQubGVmdCAtIG9yaWdpbmFsTGVmdCkgKiAyLCBvZmZzZXRXaWR0aCwgJ2xlZnQnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG9yaWdpbmFsVG9wICE9PSB0aXBPZmZzZXQudG9wKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3JlcGxhY2VBcnJvdygkdGlwLCAodGlwT2Zmc2V0LnRvcCAtIG9yaWdpbmFsVG9wKSAqIDIsIG9mZnNldEhlaWdodCwgJ3RvcCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIFRvdXIucHJvdG90eXBlLl9jZW50ZXIgPSBmdW5jdGlvbigkdGlwKSB7XG4gICAgICByZXR1cm4gJHRpcC5jc3MoJ3RvcCcsICQod2luZG93KS5vdXRlckhlaWdodCgpIC8gMiAtICR0aXAub3V0ZXJIZWlnaHQoKSAvIDIpO1xuICAgIH07XG5cbiAgICBUb3VyLnByb3RvdHlwZS5fcmVwbGFjZUFycm93ID0gZnVuY3Rpb24oJHRpcCwgZGVsdGEsIGRpbWVuc2lvbiwgcG9zaXRpb24pIHtcbiAgICAgIHJldHVybiAkdGlwLmZpbmQoJy5hcnJvdycpLmNzcyhwb3NpdGlvbiwgZGVsdGEgPyA1MCAqICgxIC0gZGVsdGEgLyBkaW1lbnNpb24pICsgJyUnIDogJycpO1xuICAgIH07XG5cbiAgICBUb3VyLnByb3RvdHlwZS5fc2Nyb2xsSW50b1ZpZXcgPSBmdW5jdGlvbihpKSB7XG4gICAgICB2YXIgJGVsZW1lbnQsICR3aW5kb3csIGNvdW50ZXIsIGhlaWdodCwgb2Zmc2V0VG9wLCBzY3JvbGxUb3AsIHN0ZXAsIHdpbmRvd0hlaWdodDtcbiAgICAgIHN0ZXAgPSB0aGlzLmdldFN0ZXAoaSk7XG4gICAgICAkZWxlbWVudCA9ICQoc3RlcC5lbGVtZW50KTtcbiAgICAgIGlmICghJGVsZW1lbnQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaG93UG9wb3ZlckFuZE92ZXJsYXkoaSk7XG4gICAgICB9XG4gICAgICAkd2luZG93ID0gJCh3aW5kb3cpO1xuICAgICAgb2Zmc2V0VG9wID0gJGVsZW1lbnQub2Zmc2V0KCkudG9wO1xuICAgICAgaGVpZ2h0ID0gJGVsZW1lbnQub3V0ZXJIZWlnaHQoKTtcbiAgICAgIHdpbmRvd0hlaWdodCA9ICR3aW5kb3cuaGVpZ2h0KCk7XG4gICAgICBzY3JvbGxUb3AgPSAwO1xuICAgICAgc3dpdGNoIChzdGVwLnBsYWNlbWVudCkge1xuICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgIHNjcm9sbFRvcCA9IE1hdGgubWF4KDAsIG9mZnNldFRvcCAtICh3aW5kb3dIZWlnaHQgLyAyKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgc2Nyb2xsVG9wID0gTWF0aC5tYXgoMCwgKG9mZnNldFRvcCArIGhlaWdodCAvIDIpIC0gKHdpbmRvd0hlaWdodCAvIDIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICBzY3JvbGxUb3AgPSBNYXRoLm1heCgwLCAob2Zmc2V0VG9wICsgaGVpZ2h0KSAtICh3aW5kb3dIZWlnaHQgLyAyKSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9kZWJ1ZyhcIlNjcm9sbCBpbnRvIHZpZXcuIFNjcm9sbFRvcDogXCIgKyBzY3JvbGxUb3AgKyBcIi4gRWxlbWVudCBvZmZzZXQ6IFwiICsgb2Zmc2V0VG9wICsgXCIuIFdpbmRvdyBoZWlnaHQ6IFwiICsgd2luZG93SGVpZ2h0ICsgXCIuXCIpO1xuICAgICAgY291bnRlciA9IDA7XG4gICAgICByZXR1cm4gJCgnYm9keSwgaHRtbCcpLnN0b3AodHJ1ZSwgdHJ1ZSkuYW5pbWF0ZSh7XG4gICAgICAgIHNjcm9sbFRvcDogTWF0aC5jZWlsKHNjcm9sbFRvcClcbiAgICAgIH0sIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKCsrY291bnRlciA9PT0gMikge1xuICAgICAgICAgICAgX3RoaXMuX3Nob3dQb3BvdmVyQW5kT3ZlcmxheShpKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fZGVidWcoXCJTY3JvbGwgaW50byB2aWV3LlxcbkFuaW1hdGlvbiBlbmQgZWxlbWVudCBvZmZzZXQ6IFwiICsgKCRlbGVtZW50Lm9mZnNldCgpLnRvcCkgKyBcIi5cXG5XaW5kb3cgaGVpZ2h0OiBcIiArICgkd2luZG93LmhlaWdodCgpKSArIFwiLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgfTtcblxuICAgIFRvdXIucHJvdG90eXBlLl9vblJlc2l6ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrLCB0aW1lb3V0KSB7XG4gICAgICByZXR1cm4gJCh3aW5kb3cpLm9uKFwicmVzaXplLnRvdXItXCIgKyB0aGlzLl9vcHRpb25zLm5hbWUsIGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIHJldHVybiB0aW1lb3V0ID0gc2V0VGltZW91dChjYWxsYmFjaywgMTAwKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBUb3VyLnByb3RvdHlwZS5fb25TY3JvbGwgPSBmdW5jdGlvbihjYWxsYmFjaywgdGltZW91dCkge1xuICAgICAgcmV0dXJuICQod2luZG93KS5vbihcInNjcm9sbC50b3VyLVwiICsgdGhpcy5fb3B0aW9ucy5uYW1lLCBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICByZXR1cm4gdGltZW91dCA9IHNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgVG91ci5wcm90b3R5cGUuX2luaXRNb3VzZU5hdmlnYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfdGhpcztcbiAgICAgIF90aGlzID0gdGhpcztcbiAgICAgIHJldHVybiAkKGRvY3VtZW50KS5vZmYoXCJjbGljay50b3VyLVwiICsgdGhpcy5fb3B0aW9ucy5uYW1lLCBcIi5wb3BvdmVyLnRvdXItXCIgKyB0aGlzLl9vcHRpb25zLm5hbWUgKyBcIiAqW2RhdGEtcm9sZT0ncHJldiddXCIpLm9mZihcImNsaWNrLnRvdXItXCIgKyB0aGlzLl9vcHRpb25zLm5hbWUsIFwiLnBvcG92ZXIudG91ci1cIiArIHRoaXMuX29wdGlvbnMubmFtZSArIFwiICpbZGF0YS1yb2xlPSduZXh0J11cIikub2ZmKFwiY2xpY2sudG91ci1cIiArIHRoaXMuX29wdGlvbnMubmFtZSwgXCIucG9wb3Zlci50b3VyLVwiICsgdGhpcy5fb3B0aW9ucy5uYW1lICsgXCIgKltkYXRhLXJvbGU9J2VuZCddXCIpLm9mZihcImNsaWNrLnRvdXItXCIgKyB0aGlzLl9vcHRpb25zLm5hbWUsIFwiLnBvcG92ZXIudG91ci1cIiArIHRoaXMuX29wdGlvbnMubmFtZSArIFwiICpbZGF0YS1yb2xlPSdwYXVzZS1yZXN1bWUnXVwiKS5vbihcImNsaWNrLnRvdXItXCIgKyB0aGlzLl9vcHRpb25zLm5hbWUsIFwiLnBvcG92ZXIudG91ci1cIiArIHRoaXMuX29wdGlvbnMubmFtZSArIFwiICpbZGF0YS1yb2xlPSduZXh0J11cIiwgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHJldHVybiBfdGhpcy5uZXh0KCk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSkub24oXCJjbGljay50b3VyLVwiICsgdGhpcy5fb3B0aW9ucy5uYW1lLCBcIi5wb3BvdmVyLnRvdXItXCIgKyB0aGlzLl9vcHRpb25zLm5hbWUgKyBcIiAqW2RhdGEtcm9sZT0ncHJldiddXCIsIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBpZiAoX3RoaXMuX2N1cnJlbnQgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMucHJldigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKS5vbihcImNsaWNrLnRvdXItXCIgKyB0aGlzLl9vcHRpb25zLm5hbWUsIFwiLnBvcG92ZXIudG91ci1cIiArIHRoaXMuX29wdGlvbnMubmFtZSArIFwiICpbZGF0YS1yb2xlPSdlbmQnXVwiLCAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmVuZCgpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpLm9uKFwiY2xpY2sudG91ci1cIiArIHRoaXMuX29wdGlvbnMubmFtZSwgXCIucG9wb3Zlci50b3VyLVwiICsgdGhpcy5fb3B0aW9ucy5uYW1lICsgXCIgKltkYXRhLXJvbGU9J3BhdXNlLXJlc3VtZSddXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyICR0aGlzO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICR0aGlzID0gJCh0aGlzKTtcbiAgICAgICAgJHRoaXMudGV4dChfdGhpcy5fcGF1c2VkID8gJHRoaXMuZGF0YSgncGF1c2UtdGV4dCcpIDogJHRoaXMuZGF0YSgncmVzdW1lLXRleHQnKSk7XG4gICAgICAgIGlmIChfdGhpcy5fcGF1c2VkKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLnJlc3VtZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgVG91ci5wcm90b3R5cGUuX2luaXRLZXlib2FyZE5hdmlnYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5fb3B0aW9ucy5rZXlib2FyZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gJChkb2N1bWVudCkub24oXCJrZXl1cC50b3VyLVwiICsgdGhpcy5fb3B0aW9ucy5uYW1lLCAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBpZiAoIWUud2hpY2gpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3dpdGNoIChlLndoaWNoKSB7XG4gICAgICAgICAgICBjYXNlIDM5OlxuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIGlmIChfdGhpcy5faXNMYXN0KCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMubmV4dCgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5lbmQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzc6XG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgaWYgKF90aGlzLl9jdXJyZW50ID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5wcmV2KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgfTtcblxuICAgIFRvdXIucHJvdG90eXBlLl9tYWtlUHJvbWlzZSA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgaWYgKHJlc3VsdCAmJiAkLmlzRnVuY3Rpb24ocmVzdWx0LnRoZW4pKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVG91ci5wcm90b3R5cGUuX2NhbGxPblByb21pc2VEb25lID0gZnVuY3Rpb24ocHJvbWlzZSwgY2IsIGFyZykge1xuICAgICAgaWYgKHByb21pc2UpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbigoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNiLmNhbGwoX3RoaXMsIGFyZyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNiLmNhbGwodGhpcywgYXJnKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVG91ci5wcm90b3R5cGUuX3Nob3dCYWNrZ3JvdW5kID0gZnVuY3Rpb24oc3RlcCwgZGF0YSkge1xuICAgICAgdmFyICRiYWNrZHJvcCwgYmFzZSwgaGVpZ2h0LCBqLCBsZW4sIHBvcywgcmVmLCByZXN1bHRzLCB3aWR0aDtcbiAgICAgIGhlaWdodCA9ICQoZG9jdW1lbnQpLmhlaWdodCgpO1xuICAgICAgd2lkdGggPSAkKGRvY3VtZW50KS53aWR0aCgpO1xuICAgICAgcmVmID0gWyd0b3AnLCAnYm90dG9tJywgJ2xlZnQnLCAncmlnaHQnXTtcbiAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICBwb3MgPSByZWZbal07XG4gICAgICAgICRiYWNrZHJvcCA9IChiYXNlID0gdGhpcy5iYWNrZHJvcHMpW3Bvc10gIT0gbnVsbCA/IGJhc2VbcG9zXSA6IGJhc2VbcG9zXSA9ICQoJzxkaXY+Jywge1xuICAgICAgICAgIFwiY2xhc3NcIjogXCJ0b3VyLWJhY2tkcm9wIFwiICsgcG9zXG4gICAgICAgIH0pO1xuICAgICAgICAkKHN0ZXAuYmFja2Ryb3BDb250YWluZXIpLmFwcGVuZCgkYmFja2Ryb3ApO1xuICAgICAgICBzd2l0Y2ggKHBvcykge1xuICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goJGJhY2tkcm9wLmhlaWdodChkYXRhLm9mZnNldC50b3AgPiAwID8gZGF0YS5vZmZzZXQudG9wIDogMCkud2lkdGgod2lkdGgpLm9mZnNldCh7XG4gICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgbGVmdDogMFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCgkYmFja2Ryb3Aub2Zmc2V0KHtcbiAgICAgICAgICAgICAgdG9wOiBkYXRhLm9mZnNldC50b3AgKyBkYXRhLmhlaWdodCxcbiAgICAgICAgICAgICAgbGVmdDogMFxuICAgICAgICAgICAgfSkuaGVpZ2h0KGhlaWdodCAtIChkYXRhLm9mZnNldC50b3AgKyBkYXRhLmhlaWdodCkpLndpZHRoKHdpZHRoKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCgkYmFja2Ryb3Aub2Zmc2V0KHtcbiAgICAgICAgICAgICAgdG9wOiBkYXRhLm9mZnNldC50b3AsXG4gICAgICAgICAgICAgIGxlZnQ6IDBcbiAgICAgICAgICAgIH0pLmhlaWdodChkYXRhLmhlaWdodCkud2lkdGgoZGF0YS5vZmZzZXQubGVmdCA+IDAgPyBkYXRhLm9mZnNldC5sZWZ0IDogMCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKCRiYWNrZHJvcC5vZmZzZXQoe1xuICAgICAgICAgICAgICB0b3A6IGRhdGEub2Zmc2V0LnRvcCxcbiAgICAgICAgICAgICAgbGVmdDogZGF0YS5vZmZzZXQubGVmdCArIGRhdGEud2lkdGhcbiAgICAgICAgICAgIH0pLmhlaWdodChkYXRhLmhlaWdodCkud2lkdGgod2lkdGggLSAoZGF0YS5vZmZzZXQubGVmdCArIGRhdGEud2lkdGgpKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG5cbiAgICBUb3VyLnByb3RvdHlwZS5fc2hvd092ZXJsYXlFbGVtZW50ID0gZnVuY3Rpb24oc3RlcCkge1xuICAgICAgdmFyICRiYWNrZHJvcEVsZW1lbnQsIGVsZW1lbnREYXRhO1xuICAgICAgJGJhY2tkcm9wRWxlbWVudCA9ICQoc3RlcC5iYWNrZHJvcEVsZW1lbnQpO1xuICAgICAgaWYgKCRiYWNrZHJvcEVsZW1lbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGVsZW1lbnREYXRhID0ge1xuICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICBvZmZzZXQ6IHtcbiAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgIGxlZnQ6IDBcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50RGF0YSA9IHtcbiAgICAgICAgICB3aWR0aDogJGJhY2tkcm9wRWxlbWVudC5pbm5lcldpZHRoKCksXG4gICAgICAgICAgaGVpZ2h0OiAkYmFja2Ryb3BFbGVtZW50LmlubmVySGVpZ2h0KCksXG4gICAgICAgICAgb2Zmc2V0OiAkYmFja2Ryb3BFbGVtZW50Lm9mZnNldCgpXG4gICAgICAgIH07XG4gICAgICAgICRiYWNrZHJvcEVsZW1lbnQuYWRkQ2xhc3MoJ3RvdXItc3RlcC1iYWNrZHJvcCcpO1xuICAgICAgICBpZiAoc3RlcC5iYWNrZHJvcFBhZGRpbmcpIHtcbiAgICAgICAgICBlbGVtZW50RGF0YSA9IHRoaXMuX2FwcGx5QmFja2Ryb3BQYWRkaW5nKHN0ZXAuYmFja2Ryb3BQYWRkaW5nLCBlbGVtZW50RGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9zaG93QmFja2dyb3VuZChzdGVwLCBlbGVtZW50RGF0YSk7XG4gICAgfTtcblxuICAgIFRvdXIucHJvdG90eXBlLl9oaWRlT3ZlcmxheUVsZW1lbnQgPSBmdW5jdGlvbihzdGVwKSB7XG4gICAgICB2YXIgJGJhY2tkcm9wLCBwb3MsIHJlZjtcbiAgICAgICQoc3RlcC5iYWNrZHJvcEVsZW1lbnQpLnJlbW92ZUNsYXNzKCd0b3VyLXN0ZXAtYmFja2Ryb3AnKTtcbiAgICAgIHJlZiA9IHRoaXMuYmFja2Ryb3BzO1xuICAgICAgZm9yIChwb3MgaW4gcmVmKSB7XG4gICAgICAgICRiYWNrZHJvcCA9IHJlZltwb3NdO1xuICAgICAgICBpZiAoJGJhY2tkcm9wICYmICRiYWNrZHJvcC5yZW1vdmUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICRiYWNrZHJvcC5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuYmFja2Ryb3BzID0gW107XG4gICAgfTtcblxuICAgIFRvdXIucHJvdG90eXBlLl9hcHBseUJhY2tkcm9wUGFkZGluZyA9IGZ1bmN0aW9uKHBhZGRpbmcsIGRhdGEpIHtcbiAgICAgIGlmICh0eXBlb2YgcGFkZGluZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKHBhZGRpbmcudG9wID09IG51bGwpIHtcbiAgICAgICAgICBwYWRkaW5nLnRvcCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhZGRpbmcucmlnaHQgPT0gbnVsbCkge1xuICAgICAgICAgIHBhZGRpbmcucmlnaHQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWRkaW5nLmJvdHRvbSA9PSBudWxsKSB7XG4gICAgICAgICAgcGFkZGluZy5ib3R0b20gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWRkaW5nLmxlZnQgPT0gbnVsbCkge1xuICAgICAgICAgIHBhZGRpbmcubGVmdCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YS5vZmZzZXQudG9wID0gZGF0YS5vZmZzZXQudG9wIC0gcGFkZGluZy50b3A7XG4gICAgICAgIGRhdGEub2Zmc2V0LmxlZnQgPSBkYXRhLm9mZnNldC5sZWZ0IC0gcGFkZGluZy5sZWZ0O1xuICAgICAgICBkYXRhLndpZHRoID0gZGF0YS53aWR0aCArIHBhZGRpbmcubGVmdCArIHBhZGRpbmcucmlnaHQ7XG4gICAgICAgIGRhdGEuaGVpZ2h0ID0gZGF0YS5oZWlnaHQgKyBwYWRkaW5nLnRvcCArIHBhZGRpbmcuYm90dG9tO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YS5vZmZzZXQudG9wID0gZGF0YS5vZmZzZXQudG9wIC0gcGFkZGluZztcbiAgICAgICAgZGF0YS5vZmZzZXQubGVmdCA9IGRhdGEub2Zmc2V0LmxlZnQgLSBwYWRkaW5nO1xuICAgICAgICBkYXRhLndpZHRoID0gZGF0YS53aWR0aCArIChwYWRkaW5nICogMik7XG4gICAgICAgIGRhdGEuaGVpZ2h0ID0gZGF0YS5oZWlnaHQgKyAocGFkZGluZyAqIDIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcblxuICAgIFRvdXIucHJvdG90eXBlLl9jbGVhclRpbWVyID0gZnVuY3Rpb24oKSB7XG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICAgIHJldHVybiB0aGlzLl9kdXJhdGlvbiA9IG51bGw7XG4gICAgfTtcblxuICAgIFRvdXIucHJvdG90eXBlLl9nZXRQcm90b2NvbCA9IGZ1bmN0aW9uKHVybCkge1xuICAgICAgdXJsID0gdXJsLnNwbGl0KCc6Ly8nKTtcbiAgICAgIGlmICh1cmwubGVuZ3RoID4gMSkge1xuICAgICAgICByZXR1cm4gdXJsWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICdodHRwJztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVG91ci5wcm90b3R5cGUuX2dldEhvc3QgPSBmdW5jdGlvbih1cmwpIHtcbiAgICAgIHVybCA9IHVybC5zcGxpdCgnLy8nKTtcbiAgICAgIHVybCA9IHVybC5sZW5ndGggPiAxID8gdXJsWzFdIDogdXJsWzBdO1xuICAgICAgcmV0dXJuIHVybC5zcGxpdCgnLycpWzBdO1xuICAgIH07XG5cbiAgICBUb3VyLnByb3RvdHlwZS5fZ2V0UGF0aCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoLnJlcGxhY2UoL1xcLz8kLywgJycpLnNwbGl0KCc/JylbMF0uc3BsaXQoJyMnKVswXTtcbiAgICB9O1xuXG4gICAgVG91ci5wcm90b3R5cGUuX2dldFF1ZXJ5ID0gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFBhcmFtcyhwYXRoLCAnPycpO1xuICAgIH07XG5cbiAgICBUb3VyLnByb3RvdHlwZS5fZ2V0SGFzaCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRQYXJhbXMocGF0aCwgJyMnKTtcbiAgICB9O1xuXG4gICAgVG91ci5wcm90b3R5cGUuX2dldFBhcmFtcyA9IGZ1bmN0aW9uKHBhdGgsIHN0YXJ0KSB7XG4gICAgICB2YXIgaiwgbGVuLCBwYXJhbSwgcGFyYW1zLCBwYXJhbXNPYmplY3Q7XG4gICAgICBwYXJhbXMgPSBwYXRoLnNwbGl0KHN0YXJ0KTtcbiAgICAgIGlmIChwYXJhbXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIHBhcmFtcyA9IHBhcmFtc1sxXS5zcGxpdCgnJicpO1xuICAgICAgcGFyYW1zT2JqZWN0ID0ge307XG4gICAgICBmb3IgKGogPSAwLCBsZW4gPSBwYXJhbXMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgcGFyYW0gPSBwYXJhbXNbal07XG4gICAgICAgIHBhcmFtID0gcGFyYW0uc3BsaXQoJz0nKTtcbiAgICAgICAgcGFyYW1zT2JqZWN0W3BhcmFtWzBdXSA9IHBhcmFtWzFdIHx8ICcnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmFtc09iamVjdDtcbiAgICB9O1xuXG4gICAgVG91ci5wcm90b3R5cGUuX2VxdWFsID0gZnVuY3Rpb24ob2JqMSwgb2JqMikge1xuICAgICAgdmFyIGosIGssIGxlbiwgb2JqMUtleXMsIG9iajJLZXlzLCB2O1xuICAgICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwob2JqMSkgPT09ICdbb2JqZWN0IE9iamVjdF0nICYmIHt9LnRvU3RyaW5nLmNhbGwob2JqMikgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICAgIG9iajFLZXlzID0gT2JqZWN0LmtleXMob2JqMSk7XG4gICAgICAgIG9iajJLZXlzID0gT2JqZWN0LmtleXMob2JqMik7XG4gICAgICAgIGlmIChvYmoxS2V5cy5sZW5ndGggIT09IG9iajJLZXlzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGsgaW4gb2JqMSkge1xuICAgICAgICAgIHYgPSBvYmoxW2tdO1xuICAgICAgICAgIGlmICghdGhpcy5fZXF1YWwob2JqMltrXSwgdikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHt9LnRvU3RyaW5nLmNhbGwob2JqMSkgPT09ICdbb2JqZWN0IEFycmF5XScgJiYge30udG9TdHJpbmcuY2FsbChvYmoyKSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICBpZiAob2JqMS5sZW5ndGggIT09IG9iajIubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoayA9IGogPSAwLCBsZW4gPSBvYmoxLmxlbmd0aDsgaiA8IGxlbjsgayA9ICsraikge1xuICAgICAgICAgIHYgPSBvYmoxW2tdO1xuICAgICAgICAgIGlmICghdGhpcy5fZXF1YWwodiwgb2JqMltrXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gb2JqMSA9PT0gb2JqMjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIFRvdXI7XG5cbiAgfSkoKTtcbiAgcmV0dXJuIFRvdXI7XG59KTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBLFdBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///c/xF\n");

/***/ })

}]);